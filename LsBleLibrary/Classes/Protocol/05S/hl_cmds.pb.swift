// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: hl_cmds.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum ver_t: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case pbVersion // = 1

  init() {
    self = .pbVersion
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .pbVersion
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .pbVersion: return 1
    }
  }

}

#if swift(>=4.2)

extension ver_t: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct weather_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mWeatherNum: UInt32 {
    get {return _mWeatherNum ?? 0}
    set {_mWeatherNum = newValue}
  }
  /// Returns true if `mWeatherNum` has been explicitly set.
  var hasMWeatherNum: Bool {return self._mWeatherNum != nil}
  /// Clears the value of `mWeatherNum`. Subsequent reads from it will return its default value.
  mutating func clearMWeatherNum() {self._mWeatherNum = nil}

  var mClimate: UInt32 {
    get {return _mClimate ?? 0}
    set {_mClimate = newValue}
  }
  /// Returns true if `mClimate` has been explicitly set.
  var hasMClimate: Bool {return self._mClimate != nil}
  /// Clears the value of `mClimate`. Subsequent reads from it will return its default value.
  mutating func clearMClimate() {self._mClimate = nil}

  var mTemperature: UInt32 {
    get {return _mTemperature ?? 0}
    set {_mTemperature = newValue}
  }
  /// Returns true if `mTemperature` has been explicitly set.
  var hasMTemperature: Bool {return self._mTemperature != nil}
  /// Clears the value of `mTemperature`. Subsequent reads from it will return its default value.
  mutating func clearMTemperature() {self._mTemperature = nil}

  var mPm25: UInt32 {
    get {return _mPm25 ?? 0}
    set {_mPm25 = newValue}
  }
  /// Returns true if `mPm25` has been explicitly set.
  var hasMPm25: Bool {return self._mPm25 != nil}
  /// Clears the value of `mPm25`. Subsequent reads from it will return its default value.
  mutating func clearMPm25() {self._mPm25 = nil}

  var mAqi: UInt32 {
    get {return _mAqi ?? 0}
    set {_mAqi = newValue}
  }
  /// Returns true if `mAqi` has been explicitly set.
  var hasMAqi: Bool {return self._mAqi != nil}
  /// Clears the value of `mAqi`. Subsequent reads from it will return its default value.
  mutating func clearMAqi() {self._mAqi = nil}

  var mCity: UInt32 {
    get {return _mCity ?? 0}
    set {_mCity = newValue}
  }
  /// Returns true if `mCity` has been explicitly set.
  var hasMCity: Bool {return self._mCity != nil}
  /// Clears the value of `mCity`. Subsequent reads from it will return its default value.
  mutating func clearMCity() {self._mCity = nil}

  var mMaxTemp: UInt32 {
    get {return _mMaxTemp ?? 0}
    set {_mMaxTemp = newValue}
  }
  /// Returns true if `mMaxTemp` has been explicitly set.
  var hasMMaxTemp: Bool {return self._mMaxTemp != nil}
  /// Clears the value of `mMaxTemp`. Subsequent reads from it will return its default value.
  mutating func clearMMaxTemp() {self._mMaxTemp = nil}

  var mMinTemp: UInt32 {
    get {return _mMinTemp ?? 0}
    set {_mMinTemp = newValue}
  }
  /// Returns true if `mMinTemp` has been explicitly set.
  var hasMMinTemp: Bool {return self._mMinTemp != nil}
  /// Clears the value of `mMinTemp`. Subsequent reads from it will return its default value.
  mutating func clearMMinTemp() {self._mMinTemp = nil}

  var mSeconds: UInt32 {
    get {return _mSeconds ?? 0}
    set {_mSeconds = newValue}
  }
  /// Returns true if `mSeconds` has been explicitly set.
  var hasMSeconds: Bool {return self._mSeconds != nil}
  /// Clears the value of `mSeconds`. Subsequent reads from it will return its default value.
  mutating func clearMSeconds() {self._mSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mWeatherNum: UInt32? = nil
  fileprivate var _mClimate: UInt32? = nil
  fileprivate var _mTemperature: UInt32? = nil
  fileprivate var _mPm25: UInt32? = nil
  fileprivate var _mAqi: UInt32? = nil
  fileprivate var _mCity: UInt32? = nil
  fileprivate var _mMaxTemp: UInt32? = nil
  fileprivate var _mMinTemp: UInt32? = nil
  fileprivate var _mSeconds: UInt32? = nil
}

struct alarm_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mAlarm1Cfg: Data {
    get {return _mAlarm1Cfg ?? Data()}
    set {_mAlarm1Cfg = newValue}
  }
  /// Returns true if `mAlarm1Cfg` has been explicitly set.
  var hasMAlarm1Cfg: Bool {return self._mAlarm1Cfg != nil}
  /// Clears the value of `mAlarm1Cfg`. Subsequent reads from it will return its default value.
  mutating func clearMAlarm1Cfg() {self._mAlarm1Cfg = nil}

  var mAlarm1Hour: UInt32 {
    get {return _mAlarm1Hour ?? 0}
    set {_mAlarm1Hour = newValue}
  }
  /// Returns true if `mAlarm1Hour` has been explicitly set.
  var hasMAlarm1Hour: Bool {return self._mAlarm1Hour != nil}
  /// Clears the value of `mAlarm1Hour`. Subsequent reads from it will return its default value.
  mutating func clearMAlarm1Hour() {self._mAlarm1Hour = nil}

  var mAlarm1Min: UInt32 {
    get {return _mAlarm1Min ?? 0}
    set {_mAlarm1Min = newValue}
  }
  /// Returns true if `mAlarm1Min` has been explicitly set.
  var hasMAlarm1Min: Bool {return self._mAlarm1Min != nil}
  /// Clears the value of `mAlarm1Min`. Subsequent reads from it will return its default value.
  mutating func clearMAlarm1Min() {self._mAlarm1Min = nil}

  var mAlarm1Once: UInt32 {
    get {return _mAlarm1Once ?? 0}
    set {_mAlarm1Once = newValue}
  }
  /// Returns true if `mAlarm1Once` has been explicitly set.
  var hasMAlarm1Once: Bool {return self._mAlarm1Once != nil}
  /// Clears the value of `mAlarm1Once`. Subsequent reads from it will return its default value.
  mutating func clearMAlarm1Once() {self._mAlarm1Once = nil}

  var mAlarm1Remarks: Data {
    get {return _mAlarm1Remarks ?? Data()}
    set {_mAlarm1Remarks = newValue}
  }
  /// Returns true if `mAlarm1Remarks` has been explicitly set.
  var hasMAlarm1Remarks: Bool {return self._mAlarm1Remarks != nil}
  /// Clears the value of `mAlarm1Remarks`. Subsequent reads from it will return its default value.
  mutating func clearMAlarm1Remarks() {self._mAlarm1Remarks = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mAlarm1Cfg: Data? = nil
  fileprivate var _mAlarm1Hour: UInt32? = nil
  fileprivate var _mAlarm1Min: UInt32? = nil
  fileprivate var _mAlarm1Once: UInt32? = nil
  fileprivate var _mAlarm1Remarks: Data? = nil
}

struct bind_app_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mUsrid: UInt32 {
    get {return _mUsrid ?? 0}
    set {_mUsrid = newValue}
  }
  /// Returns true if `mUsrid` has been explicitly set.
  var hasMUsrid: Bool {return self._mUsrid != nil}
  /// Clears the value of `mUsrid`. Subsequent reads from it will return its default value.
  mutating func clearMUsrid() {self._mUsrid = nil}

  var mGender: UInt32 {
    get {return _mGender ?? 0}
    set {_mGender = newValue}
  }
  /// Returns true if `mGender` has been explicitly set.
  var hasMGender: Bool {return self._mGender != nil}
  /// Clears the value of `mGender`. Subsequent reads from it will return its default value.
  mutating func clearMGender() {self._mGender = nil}

  var mAge: UInt32 {
    get {return _mAge ?? 0}
    set {_mAge = newValue}
  }
  /// Returns true if `mAge` has been explicitly set.
  var hasMAge: Bool {return self._mAge != nil}
  /// Clears the value of `mAge`. Subsequent reads from it will return its default value.
  mutating func clearMAge() {self._mAge = nil}

  var mHeight: UInt32 {
    get {return _mHeight ?? 0}
    set {_mHeight = newValue}
  }
  /// Returns true if `mHeight` has been explicitly set.
  var hasMHeight: Bool {return self._mHeight != nil}
  /// Clears the value of `mHeight`. Subsequent reads from it will return its default value.
  mutating func clearMHeight() {self._mHeight = nil}

  var mWeight: UInt32 {
    get {return _mWeight ?? 0}
    set {_mWeight = newValue}
  }
  /// Returns true if `mWeight` has been explicitly set.
  var hasMWeight: Bool {return self._mWeight != nil}
  /// Clears the value of `mWeight`. Subsequent reads from it will return its default value.
  mutating func clearMWeight() {self._mWeight = nil}

  var mWearstyle: UInt32 {
    get {return _mWearstyle ?? 0}
    set {_mWearstyle = newValue}
  }
  /// Returns true if `mWearstyle` has been explicitly set.
  var hasMWearstyle: Bool {return self._mWearstyle != nil}
  /// Clears the value of `mWearstyle`. Subsequent reads from it will return its default value.
  mutating func clearMWearstyle() {self._mWearstyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mUsrid: UInt32? = nil
  fileprivate var _mGender: UInt32? = nil
  fileprivate var _mAge: UInt32? = nil
  fileprivate var _mHeight: UInt32? = nil
  fileprivate var _mWeight: UInt32? = nil
  fileprivate var _mWearstyle: UInt32? = nil
}

struct r_bind_device_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mProjno: Data {
    get {return _mProjno ?? Data()}
    set {_mProjno = newValue}
  }
  /// Returns true if `mProjno` has been explicitly set.
  var hasMProjno: Bool {return self._mProjno != nil}
  /// Clears the value of `mProjno`. Subsequent reads from it will return its default value.
  mutating func clearMProjno() {self._mProjno = nil}

  var mHwversion: UInt32 {
    get {return _mHwversion ?? 0}
    set {_mHwversion = newValue}
  }
  /// Returns true if `mHwversion` has been explicitly set.
  var hasMHwversion: Bool {return self._mHwversion != nil}
  /// Clears the value of `mHwversion`. Subsequent reads from it will return its default value.
  mutating func clearMHwversion() {self._mHwversion = nil}

  var mFwversion: Data {
    get {return _mFwversion ?? Data()}
    set {_mFwversion = newValue}
  }
  /// Returns true if `mFwversion` has been explicitly set.
  var hasMFwversion: Bool {return self._mFwversion != nil}
  /// Clears the value of `mFwversion`. Subsequent reads from it will return its default value.
  mutating func clearMFwversion() {self._mFwversion = nil}

  var mFontversion: UInt32 {
    get {return _mFontversion ?? 0}
    set {_mFontversion = newValue}
  }
  /// Returns true if `mFontversion` has been explicitly set.
  var hasMFontversion: Bool {return self._mFontversion != nil}
  /// Clears the value of `mFontversion`. Subsequent reads from it will return its default value.
  mutating func clearMFontversion() {self._mFontversion = nil}

  var mSdversion: UInt32 {
    get {return _mSdversion ?? 0}
    set {_mSdversion = newValue}
  }
  /// Returns true if `mSdversion` has been explicitly set.
  var hasMSdversion: Bool {return self._mSdversion != nil}
  /// Clears the value of `mSdversion`. Subsequent reads from it will return its default value.
  mutating func clearMSdversion() {self._mSdversion = nil}

  var mUiversion: UInt32 {
    get {return _mUiversion ?? 0}
    set {_mUiversion = newValue}
  }
  /// Returns true if `mUiversion` has been explicitly set.
  var hasMUiversion: Bool {return self._mUiversion != nil}
  /// Clears the value of `mUiversion`. Subsequent reads from it will return its default value.
  mutating func clearMUiversion() {self._mUiversion = nil}

  var mDevicesn: UInt32 {
    get {return _mDevicesn ?? 0}
    set {_mDevicesn = newValue}
  }
  /// Returns true if `mDevicesn` has been explicitly set.
  var hasMDevicesn: Bool {return self._mDevicesn != nil}
  /// Clears the value of `mDevicesn`. Subsequent reads from it will return its default value.
  mutating func clearMDevicesn() {self._mDevicesn = nil}

  var mDevicename: UInt32 {
    get {return _mDevicename ?? 0}
    set {_mDevicename = newValue}
  }
  /// Returns true if `mDevicename` has been explicitly set.
  var hasMDevicename: Bool {return self._mDevicename != nil}
  /// Clears the value of `mDevicename`. Subsequent reads from it will return its default value.
  mutating func clearMDevicename() {self._mDevicename = nil}

  var mBattvalue: UInt32 {
    get {return _mBattvalue ?? 0}
    set {_mBattvalue = newValue}
  }
  /// Returns true if `mBattvalue` has been explicitly set.
  var hasMBattvalue: Bool {return self._mBattvalue != nil}
  /// Clears the value of `mBattvalue`. Subsequent reads from it will return its default value.
  mutating func clearMBattvalue() {self._mBattvalue = nil}

  var mDevicemac: UInt32 {
    get {return _mDevicemac ?? 0}
    set {_mDevicemac = newValue}
  }
  /// Returns true if `mDevicemac` has been explicitly set.
  var hasMDevicemac: Bool {return self._mDevicemac != nil}
  /// Clears the value of `mDevicemac`. Subsequent reads from it will return its default value.
  mutating func clearMDevicemac() {self._mDevicemac = nil}

  var mBindOperate: UInt32 {
    get {return _mBindOperate ?? 0}
    set {_mBindOperate = newValue}
  }
  /// Returns true if `mBindOperate` has been explicitly set.
  var hasMBindOperate: Bool {return self._mBindOperate != nil}
  /// Clears the value of `mBindOperate`. Subsequent reads from it will return its default value.
  mutating func clearMBindOperate() {self._mBindOperate = nil}

  var mPower: UInt32 {
    get {return _mPower ?? 0}
    set {_mPower = newValue}
  }
  /// Returns true if `mPower` has been explicitly set.
  var hasMPower: Bool {return self._mPower != nil}
  /// Clears the value of `mPower`. Subsequent reads from it will return its default value.
  mutating func clearMPower() {self._mPower = nil}

  var mLangversion: UInt32 {
    get {return _mLangversion ?? 0}
    set {_mLangversion = newValue}
  }
  /// Returns true if `mLangversion` has been explicitly set.
  var hasMLangversion: Bool {return self._mLangversion != nil}
  /// Clears the value of `mLangversion`. Subsequent reads from it will return its default value.
  mutating func clearMLangversion() {self._mLangversion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mProjno: Data? = nil
  fileprivate var _mHwversion: UInt32? = nil
  fileprivate var _mFwversion: Data? = nil
  fileprivate var _mFontversion: UInt32? = nil
  fileprivate var _mSdversion: UInt32? = nil
  fileprivate var _mUiversion: UInt32? = nil
  fileprivate var _mDevicesn: UInt32? = nil
  fileprivate var _mDevicename: UInt32? = nil
  fileprivate var _mBattvalue: UInt32? = nil
  fileprivate var _mDevicemac: UInt32? = nil
  fileprivate var _mBindOperate: UInt32? = nil
  fileprivate var _mPower: UInt32? = nil
  fileprivate var _mLangversion: UInt32? = nil
}

struct r_get_device_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mProjno: Data {
    get {return _mProjno ?? Data()}
    set {_mProjno = newValue}
  }
  /// Returns true if `mProjno` has been explicitly set.
  var hasMProjno: Bool {return self._mProjno != nil}
  /// Clears the value of `mProjno`. Subsequent reads from it will return its default value.
  mutating func clearMProjno() {self._mProjno = nil}

  var mHwversion: UInt32 {
    get {return _mHwversion ?? 0}
    set {_mHwversion = newValue}
  }
  /// Returns true if `mHwversion` has been explicitly set.
  var hasMHwversion: Bool {return self._mHwversion != nil}
  /// Clears the value of `mHwversion`. Subsequent reads from it will return its default value.
  mutating func clearMHwversion() {self._mHwversion = nil}

  var mFwversion: Data {
    get {return _mFwversion ?? Data()}
    set {_mFwversion = newValue}
  }
  /// Returns true if `mFwversion` has been explicitly set.
  var hasMFwversion: Bool {return self._mFwversion != nil}
  /// Clears the value of `mFwversion`. Subsequent reads from it will return its default value.
  mutating func clearMFwversion() {self._mFwversion = nil}

  var mFontversion: UInt32 {
    get {return _mFontversion ?? 0}
    set {_mFontversion = newValue}
  }
  /// Returns true if `mFontversion` has been explicitly set.
  var hasMFontversion: Bool {return self._mFontversion != nil}
  /// Clears the value of `mFontversion`. Subsequent reads from it will return its default value.
  mutating func clearMFontversion() {self._mFontversion = nil}

  var mSdversion: UInt32 {
    get {return _mSdversion ?? 0}
    set {_mSdversion = newValue}
  }
  /// Returns true if `mSdversion` has been explicitly set.
  var hasMSdversion: Bool {return self._mSdversion != nil}
  /// Clears the value of `mSdversion`. Subsequent reads from it will return its default value.
  mutating func clearMSdversion() {self._mSdversion = nil}

  var mUiversion: UInt32 {
    get {return _mUiversion ?? 0}
    set {_mUiversion = newValue}
  }
  /// Returns true if `mUiversion` has been explicitly set.
  var hasMUiversion: Bool {return self._mUiversion != nil}
  /// Clears the value of `mUiversion`. Subsequent reads from it will return its default value.
  mutating func clearMUiversion() {self._mUiversion = nil}

  var mDevicesn: UInt32 {
    get {return _mDevicesn ?? 0}
    set {_mDevicesn = newValue}
  }
  /// Returns true if `mDevicesn` has been explicitly set.
  var hasMDevicesn: Bool {return self._mDevicesn != nil}
  /// Clears the value of `mDevicesn`. Subsequent reads from it will return its default value.
  mutating func clearMDevicesn() {self._mDevicesn = nil}

  var mDevicename: UInt32 {
    get {return _mDevicename ?? 0}
    set {_mDevicename = newValue}
  }
  /// Returns true if `mDevicename` has been explicitly set.
  var hasMDevicename: Bool {return self._mDevicename != nil}
  /// Clears the value of `mDevicename`. Subsequent reads from it will return its default value.
  mutating func clearMDevicename() {self._mDevicename = nil}

  var mBattvalue: UInt32 {
    get {return _mBattvalue ?? 0}
    set {_mBattvalue = newValue}
  }
  /// Returns true if `mBattvalue` has been explicitly set.
  var hasMBattvalue: Bool {return self._mBattvalue != nil}
  /// Clears the value of `mBattvalue`. Subsequent reads from it will return its default value.
  mutating func clearMBattvalue() {self._mBattvalue = nil}

  var mDevicemac: UInt32 {
    get {return _mDevicemac ?? 0}
    set {_mDevicemac = newValue}
  }
  /// Returns true if `mDevicemac` has been explicitly set.
  var hasMDevicemac: Bool {return self._mDevicemac != nil}
  /// Clears the value of `mDevicemac`. Subsequent reads from it will return its default value.
  mutating func clearMDevicemac() {self._mDevicemac = nil}

  var mLangversion: UInt32 {
    get {return _mLangversion ?? 0}
    set {_mLangversion = newValue}
  }
  /// Returns true if `mLangversion` has been explicitly set.
  var hasMLangversion: Bool {return self._mLangversion != nil}
  /// Clears the value of `mLangversion`. Subsequent reads from it will return its default value.
  mutating func clearMLangversion() {self._mLangversion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mProjno: Data? = nil
  fileprivate var _mHwversion: UInt32? = nil
  fileprivate var _mFwversion: Data? = nil
  fileprivate var _mFontversion: UInt32? = nil
  fileprivate var _mSdversion: UInt32? = nil
  fileprivate var _mUiversion: UInt32? = nil
  fileprivate var _mDevicesn: UInt32? = nil
  fileprivate var _mDevicename: UInt32? = nil
  fileprivate var _mBattvalue: UInt32? = nil
  fileprivate var _mDevicemac: UInt32? = nil
  fileprivate var _mLangversion: UInt32? = nil
}

struct sync_phone_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mPhonemodel: UInt32 {
    get {return _mPhonemodel ?? 0}
    set {_mPhonemodel = newValue}
  }
  /// Returns true if `mPhonemodel` has been explicitly set.
  var hasMPhonemodel: Bool {return self._mPhonemodel != nil}
  /// Clears the value of `mPhonemodel`. Subsequent reads from it will return its default value.
  mutating func clearMPhonemodel() {self._mPhonemodel = nil}

  var mSystemversion: UInt32 {
    get {return _mSystemversion ?? 0}
    set {_mSystemversion = newValue}
  }
  /// Returns true if `mSystemversion` has been explicitly set.
  var hasMSystemversion: Bool {return self._mSystemversion != nil}
  /// Clears the value of `mSystemversion`. Subsequent reads from it will return its default value.
  mutating func clearMSystemversion() {self._mSystemversion = nil}

  var mAppversion: UInt32 {
    get {return _mAppversion ?? 0}
    set {_mAppversion = newValue}
  }
  /// Returns true if `mAppversion` has been explicitly set.
  var hasMAppversion: Bool {return self._mAppversion != nil}
  /// Clears the value of `mAppversion`. Subsequent reads from it will return its default value.
  mutating func clearMAppversion() {self._mAppversion = nil}

  var mLanguage: UInt32 {
    get {return _mLanguage ?? 0}
    set {_mLanguage = newValue}
  }
  /// Returns true if `mLanguage` has been explicitly set.
  var hasMLanguage: Bool {return self._mLanguage != nil}
  /// Clears the value of `mLanguage`. Subsequent reads from it will return its default value.
  mutating func clearMLanguage() {self._mLanguage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mPhonemodel: UInt32? = nil
  fileprivate var _mSystemversion: UInt32? = nil
  fileprivate var _mAppversion: UInt32? = nil
  fileprivate var _mLanguage: UInt32? = nil
}

struct sync_user_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mUsrid: UInt32 {
    get {return _mUsrid ?? 0}
    set {_mUsrid = newValue}
  }
  /// Returns true if `mUsrid` has been explicitly set.
  var hasMUsrid: Bool {return self._mUsrid != nil}
  /// Clears the value of `mUsrid`. Subsequent reads from it will return its default value.
  mutating func clearMUsrid() {self._mUsrid = nil}

  var mGender: UInt32 {
    get {return _mGender ?? 0}
    set {_mGender = newValue}
  }
  /// Returns true if `mGender` has been explicitly set.
  var hasMGender: Bool {return self._mGender != nil}
  /// Clears the value of `mGender`. Subsequent reads from it will return its default value.
  mutating func clearMGender() {self._mGender = nil}

  var mAge: UInt32 {
    get {return _mAge ?? 0}
    set {_mAge = newValue}
  }
  /// Returns true if `mAge` has been explicitly set.
  var hasMAge: Bool {return self._mAge != nil}
  /// Clears the value of `mAge`. Subsequent reads from it will return its default value.
  mutating func clearMAge() {self._mAge = nil}

  var mHeight: UInt32 {
    get {return _mHeight ?? 0}
    set {_mHeight = newValue}
  }
  /// Returns true if `mHeight` has been explicitly set.
  var hasMHeight: Bool {return self._mHeight != nil}
  /// Clears the value of `mHeight`. Subsequent reads from it will return its default value.
  mutating func clearMHeight() {self._mHeight = nil}

  var mWeight: UInt32 {
    get {return _mWeight ?? 0}
    set {_mWeight = newValue}
  }
  /// Returns true if `mWeight` has been explicitly set.
  var hasMWeight: Bool {return self._mWeight != nil}
  /// Clears the value of `mWeight`. Subsequent reads from it will return its default value.
  mutating func clearMWeight() {self._mWeight = nil}

  var mWearstyle: UInt32 {
    get {return _mWearstyle ?? 0}
    set {_mWearstyle = newValue}
  }
  /// Returns true if `mWearstyle` has been explicitly set.
  var hasMWearstyle: Bool {return self._mWearstyle != nil}
  /// Clears the value of `mWearstyle`. Subsequent reads from it will return its default value.
  mutating func clearMWearstyle() {self._mWearstyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mUsrid: UInt32? = nil
  fileprivate var _mGender: UInt32? = nil
  fileprivate var _mAge: UInt32? = nil
  fileprivate var _mHeight: UInt32? = nil
  fileprivate var _mWeight: UInt32? = nil
  fileprivate var _mWearstyle: UInt32? = nil
}

struct set_drink_slot_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mDrinkSlot: UInt32 {
    get {return _mDrinkSlot ?? 0}
    set {_mDrinkSlot = newValue}
  }
  /// Returns true if `mDrinkSlot` has been explicitly set.
  var hasMDrinkSlot: Bool {return self._mDrinkSlot != nil}
  /// Clears the value of `mDrinkSlot`. Subsequent reads from it will return its default value.
  mutating func clearMDrinkSlot() {self._mDrinkSlot = nil}

  var mStartTime: UInt32 {
    get {return _mStartTime ?? 0}
    set {_mStartTime = newValue}
  }
  /// Returns true if `mStartTime` has been explicitly set.
  var hasMStartTime: Bool {return self._mStartTime != nil}
  /// Clears the value of `mStartTime`. Subsequent reads from it will return its default value.
  mutating func clearMStartTime() {self._mStartTime = nil}

  var mEndTime: UInt32 {
    get {return _mEndTime ?? 0}
    set {_mEndTime = newValue}
  }
  /// Returns true if `mEndTime` has been explicitly set.
  var hasMEndTime: Bool {return self._mEndTime != nil}
  /// Clears the value of `mEndTime`. Subsequent reads from it will return its default value.
  mutating func clearMEndTime() {self._mEndTime = nil}

  var mNodisturbStartTime: UInt32 {
    get {return _mNodisturbStartTime ?? 0}
    set {_mNodisturbStartTime = newValue}
  }
  /// Returns true if `mNodisturbStartTime` has been explicitly set.
  var hasMNodisturbStartTime: Bool {return self._mNodisturbStartTime != nil}
  /// Clears the value of `mNodisturbStartTime`. Subsequent reads from it will return its default value.
  mutating func clearMNodisturbStartTime() {self._mNodisturbStartTime = nil}

  var mNodisturbEndTime: UInt32 {
    get {return _mNodisturbEndTime ?? 0}
    set {_mNodisturbEndTime = newValue}
  }
  /// Returns true if `mNodisturbEndTime` has been explicitly set.
  var hasMNodisturbEndTime: Bool {return self._mNodisturbEndTime != nil}
  /// Clears the value of `mNodisturbEndTime`. Subsequent reads from it will return its default value.
  mutating func clearMNodisturbEndTime() {self._mNodisturbEndTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mDrinkSlot: UInt32? = nil
  fileprivate var _mStartTime: UInt32? = nil
  fileprivate var _mEndTime: UInt32? = nil
  fileprivate var _mNodisturbStartTime: UInt32? = nil
  fileprivate var _mNodisturbEndTime: UInt32? = nil
}

struct sync_switch_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mSwitchs: Data {
    get {return _mSwitchs ?? Data()}
    set {_mSwitchs = newValue}
  }
  /// Returns true if `mSwitchs` has been explicitly set.
  var hasMSwitchs: Bool {return self._mSwitchs != nil}
  /// Clears the value of `mSwitchs`. Subsequent reads from it will return its default value.
  mutating func clearMSwitchs() {self._mSwitchs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mSwitchs: Data? = nil
}

struct set_hr_sample_slot_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mHrSlot: UInt32 {
    get {return _mHrSlot ?? 0}
    set {_mHrSlot = newValue}
  }
  /// Returns true if `mHrSlot` has been explicitly set.
  var hasMHrSlot: Bool {return self._mHrSlot != nil}
  /// Clears the value of `mHrSlot`. Subsequent reads from it will return its default value.
  mutating func clearMHrSlot() {self._mHrSlot = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mHrSlot: UInt32? = nil
}

struct set_longsit_duration_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mLongsitDuration: UInt32 {
    get {return _mLongsitDuration ?? 0}
    set {_mLongsitDuration = newValue}
  }
  /// Returns true if `mLongsitDuration` has been explicitly set.
  var hasMLongsitDuration: Bool {return self._mLongsitDuration != nil}
  /// Clears the value of `mLongsitDuration`. Subsequent reads from it will return its default value.
  mutating func clearMLongsitDuration() {self._mLongsitDuration = nil}

  var mStartTime: UInt32 {
    get {return _mStartTime ?? 0}
    set {_mStartTime = newValue}
  }
  /// Returns true if `mStartTime` has been explicitly set.
  var hasMStartTime: Bool {return self._mStartTime != nil}
  /// Clears the value of `mStartTime`. Subsequent reads from it will return its default value.
  mutating func clearMStartTime() {self._mStartTime = nil}

  var mEndTime: UInt32 {
    get {return _mEndTime ?? 0}
    set {_mEndTime = newValue}
  }
  /// Returns true if `mEndTime` has been explicitly set.
  var hasMEndTime: Bool {return self._mEndTime != nil}
  /// Clears the value of `mEndTime`. Subsequent reads from it will return its default value.
  mutating func clearMEndTime() {self._mEndTime = nil}

  var mNodisturbStartTime: UInt32 {
    get {return _mNodisturbStartTime ?? 0}
    set {_mNodisturbStartTime = newValue}
  }
  /// Returns true if `mNodisturbStartTime` has been explicitly set.
  var hasMNodisturbStartTime: Bool {return self._mNodisturbStartTime != nil}
  /// Clears the value of `mNodisturbStartTime`. Subsequent reads from it will return its default value.
  mutating func clearMNodisturbStartTime() {self._mNodisturbStartTime = nil}

  var mNodisturbEndTime: UInt32 {
    get {return _mNodisturbEndTime ?? 0}
    set {_mNodisturbEndTime = newValue}
  }
  /// Returns true if `mNodisturbEndTime` has been explicitly set.
  var hasMNodisturbEndTime: Bool {return self._mNodisturbEndTime != nil}
  /// Clears the value of `mNodisturbEndTime`. Subsequent reads from it will return its default value.
  mutating func clearMNodisturbEndTime() {self._mNodisturbEndTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mLongsitDuration: UInt32? = nil
  fileprivate var _mStartTime: UInt32? = nil
  fileprivate var _mEndTime: UInt32? = nil
  fileprivate var _mNodisturbStartTime: UInt32? = nil
  fileprivate var _mNodisturbEndTime: UInt32? = nil
}

struct set_notdisturb_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mNotdisturbTime1: Data {
    get {return _mNotdisturbTime1 ?? Data()}
    set {_mNotdisturbTime1 = newValue}
  }
  /// Returns true if `mNotdisturbTime1` has been explicitly set.
  var hasMNotdisturbTime1: Bool {return self._mNotdisturbTime1 != nil}
  /// Clears the value of `mNotdisturbTime1`. Subsequent reads from it will return its default value.
  mutating func clearMNotdisturbTime1() {self._mNotdisturbTime1 = nil}

  var mNotdisturbTime2: Data {
    get {return _mNotdisturbTime2 ?? Data()}
    set {_mNotdisturbTime2 = newValue}
  }
  /// Returns true if `mNotdisturbTime2` has been explicitly set.
  var hasMNotdisturbTime2: Bool {return self._mNotdisturbTime2 != nil}
  /// Clears the value of `mNotdisturbTime2`. Subsequent reads from it will return its default value.
  mutating func clearMNotdisturbTime2() {self._mNotdisturbTime2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mNotdisturbTime1: Data? = nil
  fileprivate var _mNotdisturbTime2: Data? = nil
}

struct set_country_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mCountryName: Data {
    get {return _mCountryName ?? Data()}
    set {_mCountryName = newValue}
  }
  /// Returns true if `mCountryName` has been explicitly set.
  var hasMCountryName: Bool {return self._mCountryName != nil}
  /// Clears the value of `mCountryName`. Subsequent reads from it will return its default value.
  mutating func clearMCountryName() {self._mCountryName = nil}

  var mCountryTimezone: UInt32 {
    get {return _mCountryTimezone ?? 0}
    set {_mCountryTimezone = newValue}
  }
  /// Returns true if `mCountryTimezone` has been explicitly set.
  var hasMCountryTimezone: Bool {return self._mCountryTimezone != nil}
  /// Clears the value of `mCountryTimezone`. Subsequent reads from it will return its default value.
  mutating func clearMCountryTimezone() {self._mCountryTimezone = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mCountryName: Data? = nil
  fileprivate var _mCountryTimezone: UInt32? = nil
}

struct set_ui_style_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mUiStyle: UInt32 {
    get {return _mUiStyle ?? 0}
    set {_mUiStyle = newValue}
  }
  /// Returns true if `mUiStyle` has been explicitly set.
  var hasMUiStyle: Bool {return self._mUiStyle != nil}
  /// Clears the value of `mUiStyle`. Subsequent reads from it will return its default value.
  mutating func clearMUiStyle() {self._mUiStyle = nil}

  var mDialClock: UInt32 {
    get {return _mDialClock ?? 0}
    set {_mDialClock = newValue}
  }
  /// Returns true if `mDialClock` has been explicitly set.
  var hasMDialClock: Bool {return self._mDialClock != nil}
  /// Clears the value of `mDialClock`. Subsequent reads from it will return its default value.
  mutating func clearMDialClock() {self._mDialClock = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mUiStyle: UInt32? = nil
  fileprivate var _mDialClock: UInt32? = nil
}

struct set_sport_target_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mTargetCal: UInt32 {
    get {return _mTargetCal ?? 0}
    set {_mTargetCal = newValue}
  }
  /// Returns true if `mTargetCal` has been explicitly set.
  var hasMTargetCal: Bool {return self._mTargetCal != nil}
  /// Clears the value of `mTargetCal`. Subsequent reads from it will return its default value.
  mutating func clearMTargetCal() {self._mTargetCal = nil}

  var mTargetDis: UInt32 {
    get {return _mTargetDis ?? 0}
    set {_mTargetDis = newValue}
  }
  /// Returns true if `mTargetDis` has been explicitly set.
  var hasMTargetDis: Bool {return self._mTargetDis != nil}
  /// Clears the value of `mTargetDis`. Subsequent reads from it will return its default value.
  mutating func clearMTargetDis() {self._mTargetDis = nil}

  var mTargetStep: UInt32 {
    get {return _mTargetStep ?? 0}
    set {_mTargetStep = newValue}
  }
  /// Returns true if `mTargetStep` has been explicitly set.
  var hasMTargetStep: Bool {return self._mTargetStep != nil}
  /// Clears the value of `mTargetStep`. Subsequent reads from it will return its default value.
  mutating func clearMTargetStep() {self._mTargetStep = nil}

  var mTargetActime: UInt32 {
    get {return _mTargetActime ?? 0}
    set {_mTargetActime = newValue}
  }
  /// Returns true if `mTargetActime` has been explicitly set.
  var hasMTargetActime: Bool {return self._mTargetActime != nil}
  /// Clears the value of `mTargetActime`. Subsequent reads from it will return its default value.
  mutating func clearMTargetActime() {self._mTargetActime = nil}

  var mCheck: UInt32 {
    get {return _mCheck ?? 0}
    set {_mCheck = newValue}
  }
  /// Returns true if `mCheck` has been explicitly set.
  var hasMCheck: Bool {return self._mCheck != nil}
  /// Clears the value of `mCheck`. Subsequent reads from it will return its default value.
  mutating func clearMCheck() {self._mCheck = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mTargetCal: UInt32? = nil
  fileprivate var _mTargetDis: UInt32? = nil
  fileprivate var _mTargetStep: UInt32? = nil
  fileprivate var _mTargetActime: UInt32? = nil
  fileprivate var _mCheck: UInt32? = nil
}

struct set_time_format_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mTimeFormat: UInt32 {
    get {return _mTimeFormat ?? 0}
    set {_mTimeFormat = newValue}
  }
  /// Returns true if `mTimeFormat` has been explicitly set.
  var hasMTimeFormat: Bool {return self._mTimeFormat != nil}
  /// Clears the value of `mTimeFormat`. Subsequent reads from it will return its default value.
  mutating func clearMTimeFormat() {self._mTimeFormat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mTimeFormat: UInt32? = nil
}

struct set_metric_inch_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mMetricInch: UInt32 {
    get {return _mMetricInch ?? 0}
    set {_mMetricInch = newValue}
  }
  /// Returns true if `mMetricInch` has been explicitly set.
  var hasMMetricInch: Bool {return self._mMetricInch != nil}
  /// Clears the value of `mMetricInch`. Subsequent reads from it will return its default value.
  mutating func clearMMetricInch() {self._mMetricInch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mMetricInch: UInt32? = nil
}

struct set_bright_times_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mBrightTime: UInt32 {
    get {return _mBrightTime ?? 0}
    set {_mBrightTime = newValue}
  }
  /// Returns true if `mBrightTime` has been explicitly set.
  var hasMBrightTime: Bool {return self._mBrightTime != nil}
  /// Clears the value of `mBrightTime`. Subsequent reads from it will return its default value.
  mutating func clearMBrightTime() {self._mBrightTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mBrightTime: UInt32? = nil
}

struct set_hr_warning_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mHrUpper: UInt32 {
    get {return _mHrUpper ?? 0}
    set {_mHrUpper = newValue}
  }
  /// Returns true if `mHrUpper` has been explicitly set.
  var hasMHrUpper: Bool {return self._mHrUpper != nil}
  /// Clears the value of `mHrUpper`. Subsequent reads from it will return its default value.
  mutating func clearMHrUpper() {self._mHrUpper = nil}

  var mHrLower: UInt32 {
    get {return _mHrLower ?? 0}
    set {_mHrLower = newValue}
  }
  /// Returns true if `mHrLower` has been explicitly set.
  var hasMHrLower: Bool {return self._mHrLower != nil}
  /// Clears the value of `mHrLower`. Subsequent reads from it will return its default value.
  mutating func clearMHrLower() {self._mHrLower = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mHrUpper: UInt32? = nil
  fileprivate var _mHrLower: UInt32? = nil
}

struct r_get_hr_value_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mHrValue: UInt32 {
    get {return _mHrValue ?? 0}
    set {_mHrValue = newValue}
  }
  /// Returns true if `mHrValue` has been explicitly set.
  var hasMHrValue: Bool {return self._mHrValue != nil}
  /// Clears the value of `mHrValue`. Subsequent reads from it will return its default value.
  mutating func clearMHrValue() {self._mHrValue = nil}

  var mErrCode: UInt32 {
    get {return _mErrCode ?? 0}
    set {_mErrCode = newValue}
  }
  /// Returns true if `mErrCode` has been explicitly set.
  var hasMErrCode: Bool {return self._mErrCode != nil}
  /// Clears the value of `mErrCode`. Subsequent reads from it will return its default value.
  mutating func clearMErrCode() {self._mErrCode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mHrValue: UInt32? = nil
  fileprivate var _mErrCode: UInt32? = nil
}

struct set_notify_warning_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mNotifyType: UInt32 {
    get {return _mNotifyType ?? 0}
    set {_mNotifyType = newValue}
  }
  /// Returns true if `mNotifyType` has been explicitly set.
  var hasMNotifyType: Bool {return self._mNotifyType != nil}
  /// Clears the value of `mNotifyType`. Subsequent reads from it will return its default value.
  mutating func clearMNotifyType() {self._mNotifyType = nil}

  var mTitleLen: UInt32 {
    get {return _mTitleLen ?? 0}
    set {_mTitleLen = newValue}
  }
  /// Returns true if `mTitleLen` has been explicitly set.
  var hasMTitleLen: Bool {return self._mTitleLen != nil}
  /// Clears the value of `mTitleLen`. Subsequent reads from it will return its default value.
  mutating func clearMTitleLen() {self._mTitleLen = nil}

  var mMsgLen: UInt32 {
    get {return _mMsgLen ?? 0}
    set {_mMsgLen = newValue}
  }
  /// Returns true if `mMsgLen` has been explicitly set.
  var hasMMsgLen: Bool {return self._mMsgLen != nil}
  /// Clears the value of `mMsgLen`. Subsequent reads from it will return its default value.
  mutating func clearMMsgLen() {self._mMsgLen = nil}

  var mReserved: Data {
    get {return _mReserved ?? Data()}
    set {_mReserved = newValue}
  }
  /// Returns true if `mReserved` has been explicitly set.
  var hasMReserved: Bool {return self._mReserved != nil}
  /// Clears the value of `mReserved`. Subsequent reads from it will return its default value.
  mutating func clearMReserved() {self._mReserved = nil}

  var mTitle: Data {
    get {return _mTitle ?? Data()}
    set {_mTitle = newValue}
  }
  /// Returns true if `mTitle` has been explicitly set.
  var hasMTitle: Bool {return self._mTitle != nil}
  /// Clears the value of `mTitle`. Subsequent reads from it will return its default value.
  mutating func clearMTitle() {self._mTitle = nil}

  var mMsg: Data {
    get {return _mMsg ?? Data()}
    set {_mMsg = newValue}
  }
  /// Returns true if `mMsg` has been explicitly set.
  var hasMMsg: Bool {return self._mMsg != nil}
  /// Clears the value of `mMsg`. Subsequent reads from it will return its default value.
  mutating func clearMMsg() {self._mMsg = nil}

  var mUtc: UInt32 {
    get {return _mUtc ?? 0}
    set {_mUtc = newValue}
  }
  /// Returns true if `mUtc` has been explicitly set.
  var hasMUtc: Bool {return self._mUtc != nil}
  /// Clears the value of `mUtc`. Subsequent reads from it will return its default value.
  mutating func clearMUtc() {self._mUtc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mNotifyType: UInt32? = nil
  fileprivate var _mTitleLen: UInt32? = nil
  fileprivate var _mMsgLen: UInt32? = nil
  fileprivate var _mReserved: Data? = nil
  fileprivate var _mTitle: Data? = nil
  fileprivate var _mMsg: Data? = nil
  fileprivate var _mUtc: UInt32? = nil
}

struct r_sync_health_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mSyncType: UInt32 {
    get {return _mSyncType ?? 0}
    set {_mSyncType = newValue}
  }
  /// Returns true if `mSyncType` has been explicitly set.
  var hasMSyncType: Bool {return self._mSyncType != nil}
  /// Clears the value of `mSyncType`. Subsequent reads from it will return its default value.
  mutating func clearMSyncType() {self._mSyncType = nil}

  var mSecondStart: UInt32 {
    get {return _mSecondStart ?? 0}
    set {_mSecondStart = newValue}
  }
  /// Returns true if `mSecondStart` has been explicitly set.
  var hasMSecondStart: Bool {return self._mSecondStart != nil}
  /// Clears the value of `mSecondStart`. Subsequent reads from it will return its default value.
  mutating func clearMSecondStart() {self._mSecondStart = nil}

  var mSecondEnd: UInt32 {
    get {return _mSecondEnd ?? 0}
    set {_mSecondEnd = newValue}
  }
  /// Returns true if `mSecondEnd` has been explicitly set.
  var hasMSecondEnd: Bool {return self._mSecondEnd != nil}
  /// Clears the value of `mSecondEnd`. Subsequent reads from it will return its default value.
  mutating func clearMSecondEnd() {self._mSecondEnd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mSyncType: UInt32? = nil
  fileprivate var _mSecondStart: UInt32? = nil
  fileprivate var _mSecondEnd: UInt32? = nil
}

struct r_get_health_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mErrCode: UInt32 {
    get {return _mErrCode ?? 0}
    set {_mErrCode = newValue}
  }
  /// Returns true if `mErrCode` has been explicitly set.
  var hasMErrCode: Bool {return self._mErrCode != nil}
  /// Clears the value of `mErrCode`. Subsequent reads from it will return its default value.
  mutating func clearMErrCode() {self._mErrCode = nil}

  var mSn: UInt32 {
    get {return _mSn ?? 0}
    set {_mSn = newValue}
  }
  /// Returns true if `mSn` has been explicitly set.
  var hasMSn: Bool {return self._mSn != nil}
  /// Clears the value of `mSn`. Subsequent reads from it will return its default value.
  mutating func clearMSn() {self._mSn = nil}

  var mData: Data {
    get {return _mData ?? Data()}
    set {_mData = newValue}
  }
  /// Returns true if `mData` has been explicitly set.
  var hasMData: Bool {return self._mData != nil}
  /// Clears the value of `mData`. Subsequent reads from it will return its default value.
  mutating func clearMData() {self._mData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mErrCode: UInt32? = nil
  fileprivate var _mSn: UInt32? = nil
  fileprivate var _mData: Data? = nil
}

struct r_get_power_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mErrCode: UInt32 {
    get {return _mErrCode ?? 0}
    set {_mErrCode = newValue}
  }
  /// Returns true if `mErrCode` has been explicitly set.
  var hasMErrCode: Bool {return self._mErrCode != nil}
  /// Clears the value of `mErrCode`. Subsequent reads from it will return its default value.
  mutating func clearMErrCode() {self._mErrCode = nil}

  var mPower: UInt32 {
    get {return _mPower ?? 0}
    set {_mPower = newValue}
  }
  /// Returns true if `mPower` has been explicitly set.
  var hasMPower: Bool {return self._mPower != nil}
  /// Clears the value of `mPower`. Subsequent reads from it will return its default value.
  mutating func clearMPower() {self._mPower = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mErrCode: UInt32? = nil
  fileprivate var _mPower: UInt32? = nil
}

struct set_updata_fw_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mNewVersion: UInt32 {
    get {return _mNewVersion ?? 0}
    set {_mNewVersion = newValue}
  }
  /// Returns true if `mNewVersion` has been explicitly set.
  var hasMNewVersion: Bool {return self._mNewVersion != nil}
  /// Clears the value of `mNewVersion`. Subsequent reads from it will return its default value.
  mutating func clearMNewVersion() {self._mNewVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mNewVersion: UInt32? = nil
}

struct set_weather_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var weathers: [weather_t] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct set_reset_machine_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mFactoryMode: UInt32 {
    get {return _mFactoryMode ?? 0}
    set {_mFactoryMode = newValue}
  }
  /// Returns true if `mFactoryMode` has been explicitly set.
  var hasMFactoryMode: Bool {return self._mFactoryMode != nil}
  /// Clears the value of `mFactoryMode`. Subsequent reads from it will return its default value.
  mutating func clearMFactoryMode() {self._mFactoryMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mFactoryMode: UInt32? = nil
}

struct set_sport_status_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mSportMode: UInt32 {
    get {return _mSportMode ?? 0}
    set {_mSportMode = newValue}
  }
  /// Returns true if `mSportMode` has been explicitly set.
  var hasMSportMode: Bool {return self._mSportMode != nil}
  /// Clears the value of `mSportMode`. Subsequent reads from it will return its default value.
  mutating func clearMSportMode() {self._mSportMode = nil}

  var mSportStatus: UInt32 {
    get {return _mSportStatus ?? 0}
    set {_mSportStatus = newValue}
  }
  /// Returns true if `mSportStatus` has been explicitly set.
  var hasMSportStatus: Bool {return self._mSportStatus != nil}
  /// Clears the value of `mSportStatus`. Subsequent reads from it will return its default value.
  mutating func clearMSportStatus() {self._mSportStatus = nil}

  var mSportSpeed: UInt32 {
    get {return _mSportSpeed ?? 0}
    set {_mSportSpeed = newValue}
  }
  /// Returns true if `mSportSpeed` has been explicitly set.
  var hasMSportSpeed: Bool {return self._mSportSpeed != nil}
  /// Clears the value of `mSportSpeed`. Subsequent reads from it will return its default value.
  mutating func clearMSportSpeed() {self._mSportSpeed = nil}

  var mSportDistance: Float {
    get {return _mSportDistance ?? 0}
    set {_mSportDistance = newValue}
  }
  /// Returns true if `mSportDistance` has been explicitly set.
  var hasMSportDistance: Bool {return self._mSportDistance != nil}
  /// Clears the value of `mSportDistance`. Subsequent reads from it will return its default value.
  mutating func clearMSportDistance() {self._mSportDistance = nil}

  var mSportCalorie: UInt32 {
    get {return _mSportCalorie ?? 0}
    set {_mSportCalorie = newValue}
  }
  /// Returns true if `mSportCalorie` has been explicitly set.
  var hasMSportCalorie: Bool {return self._mSportCalorie != nil}
  /// Clears the value of `mSportCalorie`. Subsequent reads from it will return its default value.
  mutating func clearMSportCalorie() {self._mSportCalorie = nil}

  var mSportFlag: UInt32 {
    get {return _mSportFlag ?? 0}
    set {_mSportFlag = newValue}
  }
  /// Returns true if `mSportFlag` has been explicitly set.
  var hasMSportFlag: Bool {return self._mSportFlag != nil}
  /// Clears the value of `mSportFlag`. Subsequent reads from it will return its default value.
  mutating func clearMSportFlag() {self._mSportFlag = nil}

  var mSportDuration: UInt32 {
    get {return _mSportDuration ?? 0}
    set {_mSportDuration = newValue}
  }
  /// Returns true if `mSportDuration` has been explicitly set.
  var hasMSportDuration: Bool {return self._mSportDuration != nil}
  /// Clears the value of `mSportDuration`. Subsequent reads from it will return its default value.
  mutating func clearMSportDuration() {self._mSportDuration = nil}

  var mSportSecond: UInt32 {
    get {return _mSportSecond ?? 0}
    set {_mSportSecond = newValue}
  }
  /// Returns true if `mSportSecond` has been explicitly set.
  var hasMSportSecond: Bool {return self._mSportSecond != nil}
  /// Clears the value of `mSportSecond`. Subsequent reads from it will return its default value.
  mutating func clearMSportSecond() {self._mSportSecond = nil}

  var mSportStep: UInt32 {
    get {return _mSportStep ?? 0}
    set {_mSportStep = newValue}
  }
  /// Returns true if `mSportStep` has been explicitly set.
  var hasMSportStep: Bool {return self._mSportStep != nil}
  /// Clears the value of `mSportStep`. Subsequent reads from it will return its default value.
  mutating func clearMSportStep() {self._mSportStep = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mSportMode: UInt32? = nil
  fileprivate var _mSportStatus: UInt32? = nil
  fileprivate var _mSportSpeed: UInt32? = nil
  fileprivate var _mSportDistance: Float? = nil
  fileprivate var _mSportCalorie: UInt32? = nil
  fileprivate var _mSportFlag: UInt32? = nil
  fileprivate var _mSportDuration: UInt32? = nil
  fileprivate var _mSportSecond: UInt32? = nil
  fileprivate var _mSportStep: UInt32? = nil
}

struct r_get_sport_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mSportMode: UInt32 {
    get {return _mSportMode ?? 0}
    set {_mSportMode = newValue}
  }
  /// Returns true if `mSportMode` has been explicitly set.
  var hasMSportMode: Bool {return self._mSportMode != nil}
  /// Clears the value of `mSportMode`. Subsequent reads from it will return its default value.
  mutating func clearMSportMode() {self._mSportMode = nil}

  var mSportStatus: UInt32 {
    get {return _mSportStatus ?? 0}
    set {_mSportStatus = newValue}
  }
  /// Returns true if `mSportStatus` has been explicitly set.
  var hasMSportStatus: Bool {return self._mSportStatus != nil}
  /// Clears the value of `mSportStatus`. Subsequent reads from it will return its default value.
  mutating func clearMSportStatus() {self._mSportStatus = nil}

  var mSportStep: UInt32 {
    get {return _mSportStep ?? 0}
    set {_mSportStep = newValue}
  }
  /// Returns true if `mSportStep` has been explicitly set.
  var hasMSportStep: Bool {return self._mSportStep != nil}
  /// Clears the value of `mSportStep`. Subsequent reads from it will return its default value.
  mutating func clearMSportStep() {self._mSportStep = nil}

  var mSportCalorie: UInt32 {
    get {return _mSportCalorie ?? 0}
    set {_mSportCalorie = newValue}
  }
  /// Returns true if `mSportCalorie` has been explicitly set.
  var hasMSportCalorie: Bool {return self._mSportCalorie != nil}
  /// Clears the value of `mSportCalorie`. Subsequent reads from it will return its default value.
  mutating func clearMSportCalorie() {self._mSportCalorie = nil}

  var mSportHeart: UInt32 {
    get {return _mSportHeart ?? 0}
    set {_mSportHeart = newValue}
  }
  /// Returns true if `mSportHeart` has been explicitly set.
  var hasMSportHeart: Bool {return self._mSportHeart != nil}
  /// Clears the value of `mSportHeart`. Subsequent reads from it will return its default value.
  mutating func clearMSportHeart() {self._mSportHeart = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mSportMode: UInt32? = nil
  fileprivate var _mSportStatus: UInt32? = nil
  fileprivate var _mSportStep: UInt32? = nil
  fileprivate var _mSportCalorie: UInt32? = nil
  fileprivate var _mSportHeart: UInt32? = nil
}

struct set_music_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mMusicCtrCode: UInt32 {
    get {return _mMusicCtrCode ?? 0}
    set {_mMusicCtrCode = newValue}
  }
  /// Returns true if `mMusicCtrCode` has been explicitly set.
  var hasMMusicCtrCode: Bool {return self._mMusicCtrCode != nil}
  /// Clears the value of `mMusicCtrCode`. Subsequent reads from it will return its default value.
  mutating func clearMMusicCtrCode() {self._mMusicCtrCode = nil}

  var mMusicVolume: UInt32 {
    get {return _mMusicVolume ?? 0}
    set {_mMusicVolume = newValue}
  }
  /// Returns true if `mMusicVolume` has been explicitly set.
  var hasMMusicVolume: Bool {return self._mMusicVolume != nil}
  /// Clears the value of `mMusicVolume`. Subsequent reads from it will return its default value.
  mutating func clearMMusicVolume() {self._mMusicVolume = nil}

  var mMusicTitle: Data {
    get {return _mMusicTitle ?? Data()}
    set {_mMusicTitle = newValue}
  }
  /// Returns true if `mMusicTitle` has been explicitly set.
  var hasMMusicTitle: Bool {return self._mMusicTitle != nil}
  /// Clears the value of `mMusicTitle`. Subsequent reads from it will return its default value.
  mutating func clearMMusicTitle() {self._mMusicTitle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mMusicCtrCode: UInt32? = nil
  fileprivate var _mMusicVolume: UInt32? = nil
  fileprivate var _mMusicTitle: Data? = nil
}

struct r_get_mtu_size_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mErrCode: UInt32 {
    get {return _mErrCode ?? 0}
    set {_mErrCode = newValue}
  }
  /// Returns true if `mErrCode` has been explicitly set.
  var hasMErrCode: Bool {return self._mErrCode != nil}
  /// Clears the value of `mErrCode`. Subsequent reads from it will return its default value.
  mutating func clearMErrCode() {self._mErrCode = nil}

  var mMtu: UInt32 {
    get {return _mMtu ?? 0}
    set {_mMtu = newValue}
  }
  /// Returns true if `mMtu` has been explicitly set.
  var hasMMtu: Bool {return self._mMtu != nil}
  /// Clears the value of `mMtu`. Subsequent reads from it will return its default value.
  mutating func clearMMtu() {self._mMtu = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mErrCode: UInt32? = nil
  fileprivate var _mMtu: UInt32? = nil
}

struct set_bin_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mSn: UInt32 {
    get {return _mSn ?? 0}
    set {_mSn = newValue}
  }
  /// Returns true if `mSn` has been explicitly set.
  var hasMSn: Bool {return self._mSn != nil}
  /// Clears the value of `mSn`. Subsequent reads from it will return its default value.
  mutating func clearMSn() {self._mSn = nil}

  var mData: Data {
    get {return _mData ?? Data()}
    set {_mData = newValue}
  }
  /// Returns true if `mData` has been explicitly set.
  var hasMData: Bool {return self._mData != nil}
  /// Clears the value of `mData`. Subsequent reads from it will return its default value.
  mutating func clearMData() {self._mData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mSn: UInt32? = nil
  fileprivate var _mData: Data? = nil
}

struct set_big_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mType: UInt32 {
    get {return _mType ?? 0}
    set {_mType = newValue}
  }
  /// Returns true if `mType` has been explicitly set.
  var hasMType: Bool {return self._mType != nil}
  /// Clears the value of `mType`. Subsequent reads from it will return its default value.
  mutating func clearMType() {self._mType = nil}

  var mDataLenth: UInt32 {
    get {return _mDataLenth ?? 0}
    set {_mDataLenth = newValue}
  }
  /// Returns true if `mDataLenth` has been explicitly set.
  var hasMDataLenth: Bool {return self._mDataLenth != nil}
  /// Clears the value of `mDataLenth`. Subsequent reads from it will return its default value.
  mutating func clearMDataLenth() {self._mDataLenth = nil}

  var mPicID: UInt32 {
    get {return _mPicID ?? 0}
    set {_mPicID = newValue}
  }
  /// Returns true if `mPicID` has been explicitly set.
  var hasMPicID: Bool {return self._mPicID != nil}
  /// Clears the value of `mPicID`. Subsequent reads from it will return its default value.
  mutating func clearMPicID() {self._mPicID = nil}

  var mCrcCode: UInt32 {
    get {return _mCrcCode ?? 0}
    set {_mCrcCode = newValue}
  }
  /// Returns true if `mCrcCode` has been explicitly set.
  var hasMCrcCode: Bool {return self._mCrcCode != nil}
  /// Clears the value of `mCrcCode`. Subsequent reads from it will return its default value.
  mutating func clearMCrcCode() {self._mCrcCode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mType: UInt32? = nil
  fileprivate var _mDataLenth: UInt32? = nil
  fileprivate var _mPicID: UInt32? = nil
  fileprivate var _mCrcCode: UInt32? = nil
}

struct set_alarms_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alarms: [alarm_t] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct set_rtimehr_dur_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mHrDuration: UInt32 {
    get {return _mHrDuration ?? 0}
    set {_mHrDuration = newValue}
  }
  /// Returns true if `mHrDuration` has been explicitly set.
  var hasMHrDuration: Bool {return self._mHrDuration != nil}
  /// Clears the value of `mHrDuration`. Subsequent reads from it will return its default value.
  mutating func clearMHrDuration() {self._mHrDuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mHrDuration: UInt32? = nil
}

struct r_rtimehr_value_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mHrValue: UInt32 {
    get {return _mHrValue ?? 0}
    set {_mHrValue = newValue}
  }
  /// Returns true if `mHrValue` has been explicitly set.
  var hasMHrValue: Bool {return self._mHrValue != nil}
  /// Clears the value of `mHrValue`. Subsequent reads from it will return its default value.
  mutating func clearMHrValue() {self._mHrValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mHrValue: UInt32? = nil
}

struct r_error_code_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: UInt32 {
    get {return _err ?? 0}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: UInt32? = nil
}

struct r_find_phone_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mRingStatus: UInt32 {
    get {return _mRingStatus ?? 0}
    set {_mRingStatus = newValue}
  }
  /// Returns true if `mRingStatus` has been explicitly set.
  var hasMRingStatus: Bool {return self._mRingStatus != nil}
  /// Clears the value of `mRingStatus`. Subsequent reads from it will return its default value.
  mutating func clearMRingStatus() {self._mRingStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mRingStatus: UInt32? = nil
}

struct r_get_disturb_en_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mDisturbEn: UInt32 {
    get {return _mDisturbEn ?? 0}
    set {_mDisturbEn = newValue}
  }
  /// Returns true if `mDisturbEn` has been explicitly set.
  var hasMDisturbEn: Bool {return self._mDisturbEn != nil}
  /// Clears the value of `mDisturbEn`. Subsequent reads from it will return its default value.
  mutating func clearMDisturbEn() {self._mDisturbEn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mDisturbEn: UInt32? = nil
}

struct r_get_step_count_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mStepCount: UInt32 {
    get {return _mStepCount ?? 0}
    set {_mStepCount = newValue}
  }
  /// Returns true if `mStepCount` has been explicitly set.
  var hasMStepCount: Bool {return self._mStepCount != nil}
  /// Clears the value of `mStepCount`. Subsequent reads from it will return its default value.
  mutating func clearMStepCount() {self._mStepCount = nil}

  var mTimeSecond: UInt32 {
    get {return _mTimeSecond ?? 0}
    set {_mTimeSecond = newValue}
  }
  /// Returns true if `mTimeSecond` has been explicitly set.
  var hasMTimeSecond: Bool {return self._mTimeSecond != nil}
  /// Clears the value of `mTimeSecond`. Subsequent reads from it will return its default value.
  mutating func clearMTimeSecond() {self._mTimeSecond = nil}

  var mStepCalorie: UInt32 {
    get {return _mStepCalorie ?? 0}
    set {_mStepCalorie = newValue}
  }
  /// Returns true if `mStepCalorie` has been explicitly set.
  var hasMStepCalorie: Bool {return self._mStepCalorie != nil}
  /// Clears the value of `mStepCalorie`. Subsequent reads from it will return its default value.
  mutating func clearMStepCalorie() {self._mStepCalorie = nil}

  var mStepDistance: UInt32 {
    get {return _mStepDistance ?? 0}
    set {_mStepDistance = newValue}
  }
  /// Returns true if `mStepDistance` has been explicitly set.
  var hasMStepDistance: Bool {return self._mStepDistance != nil}
  /// Clears the value of `mStepDistance`. Subsequent reads from it will return its default value.
  mutating func clearMStepDistance() {self._mStepDistance = nil}

  var mActiveduration: UInt32 {
    get {return _mActiveduration ?? 0}
    set {_mActiveduration = newValue}
  }
  /// Returns true if `mActiveduration` has been explicitly set.
  var hasMActiveduration: Bool {return self._mActiveduration != nil}
  /// Clears the value of `mActiveduration`. Subsequent reads from it will return its default value.
  mutating func clearMActiveduration() {self._mActiveduration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mStepCount: UInt32? = nil
  fileprivate var _mTimeSecond: UInt32? = nil
  fileprivate var _mStepCalorie: UInt32? = nil
  fileprivate var _mStepDistance: UInt32? = nil
  fileprivate var _mActiveduration: UInt32? = nil
}

struct r_get_current_hr_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mCurrentHr: UInt32 {
    get {return _mCurrentHr ?? 0}
    set {_mCurrentHr = newValue}
  }
  /// Returns true if `mCurrentHr` has been explicitly set.
  var hasMCurrentHr: Bool {return self._mCurrentHr != nil}
  /// Clears the value of `mCurrentHr`. Subsequent reads from it will return its default value.
  mutating func clearMCurrentHr() {self._mCurrentHr = nil}

  var mCurSportStatus: UInt32 {
    get {return _mCurSportStatus ?? 0}
    set {_mCurSportStatus = newValue}
  }
  /// Returns true if `mCurSportStatus` has been explicitly set.
  var hasMCurSportStatus: Bool {return self._mCurSportStatus != nil}
  /// Clears the value of `mCurSportStatus`. Subsequent reads from it will return its default value.
  mutating func clearMCurSportStatus() {self._mCurSportStatus = nil}

  var mStep: UInt32 {
    get {return _mStep ?? 0}
    set {_mStep = newValue}
  }
  /// Returns true if `mStep` has been explicitly set.
  var hasMStep: Bool {return self._mStep != nil}
  /// Clears the value of `mStep`. Subsequent reads from it will return its default value.
  mutating func clearMStep() {self._mStep = nil}

  var mCaloriesKcal: UInt32 {
    get {return _mCaloriesKcal ?? 0}
    set {_mCaloriesKcal = newValue}
  }
  /// Returns true if `mCaloriesKcal` has been explicitly set.
  var hasMCaloriesKcal: Bool {return self._mCaloriesKcal != nil}
  /// Clears the value of `mCaloriesKcal`. Subsequent reads from it will return its default value.
  mutating func clearMCaloriesKcal() {self._mCaloriesKcal = nil}

  var mDistanceM: UInt32 {
    get {return _mDistanceM ?? 0}
    set {_mDistanceM = newValue}
  }
  /// Returns true if `mDistanceM` has been explicitly set.
  var hasMDistanceM: Bool {return self._mDistanceM != nil}
  /// Clears the value of `mDistanceM`. Subsequent reads from it will return its default value.
  mutating func clearMDistanceM() {self._mDistanceM = nil}

  var mTimeSecond: UInt32 {
    get {return _mTimeSecond ?? 0}
    set {_mTimeSecond = newValue}
  }
  /// Returns true if `mTimeSecond` has been explicitly set.
  var hasMTimeSecond: Bool {return self._mTimeSecond != nil}
  /// Clears the value of `mTimeSecond`. Subsequent reads from it will return its default value.
  mutating func clearMTimeSecond() {self._mTimeSecond = nil}

  var mSpaceSkm: UInt32 {
    get {return _mSpaceSkm ?? 0}
    set {_mSpaceSkm = newValue}
  }
  /// Returns true if `mSpaceSkm` has been explicitly set.
  var hasMSpaceSkm: Bool {return self._mSpaceSkm != nil}
  /// Clears the value of `mSpaceSkm`. Subsequent reads from it will return its default value.
  mutating func clearMSpaceSkm() {self._mSpaceSkm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mCurrentHr: UInt32? = nil
  fileprivate var _mCurSportStatus: UInt32? = nil
  fileprivate var _mStep: UInt32? = nil
  fileprivate var _mCaloriesKcal: UInt32? = nil
  fileprivate var _mDistanceM: UInt32? = nil
  fileprivate var _mTimeSecond: UInt32? = nil
  fileprivate var _mSpaceSkm: UInt32? = nil
}

struct r_set_light_leak_result_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mCheckResult: UInt32 {
    get {return _mCheckResult ?? 0}
    set {_mCheckResult = newValue}
  }
  /// Returns true if `mCheckResult` has been explicitly set.
  var hasMCheckResult: Bool {return self._mCheckResult != nil}
  /// Clears the value of `mCheckResult`. Subsequent reads from it will return its default value.
  mutating func clearMCheckResult() {self._mCheckResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mCheckResult: UInt32? = nil
}

struct r_get_log_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mLogLength: UInt32 {
    get {return _mLogLength ?? 0}
    set {_mLogLength = newValue}
  }
  /// Returns true if `mLogLength` has been explicitly set.
  var hasMLogLength: Bool {return self._mLogLength != nil}
  /// Clears the value of `mLogLength`. Subsequent reads from it will return its default value.
  mutating func clearMLogLength() {self._mLogLength = nil}

  var mLogSn: UInt32 {
    get {return _mLogSn ?? 0}
    set {_mLogSn = newValue}
  }
  /// Returns true if `mLogSn` has been explicitly set.
  var hasMLogSn: Bool {return self._mLogSn != nil}
  /// Clears the value of `mLogSn`. Subsequent reads from it will return its default value.
  mutating func clearMLogSn() {self._mLogSn = nil}

  var mLogData: Data {
    get {return _mLogData ?? Data()}
    set {_mLogData = newValue}
  }
  /// Returns true if `mLogData` has been explicitly set.
  var hasMLogData: Bool {return self._mLogData != nil}
  /// Clears the value of `mLogData`. Subsequent reads from it will return its default value.
  mutating func clearMLogData() {self._mLogData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mLogLength: UInt32? = nil
  fileprivate var _mLogSn: UInt32? = nil
  fileprivate var _mLogData: Data? = nil
}

struct r_set_active_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mActStartTime: UInt32 {
    get {return _mActStartTime ?? 0}
    set {_mActStartTime = newValue}
  }
  /// Returns true if `mActStartTime` has been explicitly set.
  var hasMActStartTime: Bool {return self._mActStartTime != nil}
  /// Clears the value of `mActStartTime`. Subsequent reads from it will return its default value.
  mutating func clearMActStartTime() {self._mActStartTime = nil}

  var mActEndTime: UInt32 {
    get {return _mActEndTime ?? 0}
    set {_mActEndTime = newValue}
  }
  /// Returns true if `mActEndTime` has been explicitly set.
  var hasMActEndTime: Bool {return self._mActEndTime != nil}
  /// Clears the value of `mActEndTime`. Subsequent reads from it will return its default value.
  mutating func clearMActEndTime() {self._mActEndTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mActStartTime: UInt32? = nil
  fileprivate var _mActEndTime: UInt32? = nil
}

struct r_get_active_record_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mCountNum: UInt32 {
    get {return _storage._mCountNum ?? 0}
    set {_uniqueStorage()._mCountNum = newValue}
  }
  /// Returns true if `mCountNum` has been explicitly set.
  var hasMCountNum: Bool {return _storage._mCountNum != nil}
  /// Clears the value of `mCountNum`. Subsequent reads from it will return its default value.
  mutating func clearMCountNum() {_uniqueStorage()._mCountNum = nil}

  var mTotalLength: UInt32 {
    get {return _storage._mTotalLength ?? 0}
    set {_uniqueStorage()._mTotalLength = newValue}
  }
  /// Returns true if `mTotalLength` has been explicitly set.
  var hasMTotalLength: Bool {return _storage._mTotalLength != nil}
  /// Clears the value of `mTotalLength`. Subsequent reads from it will return its default value.
  mutating func clearMTotalLength() {_uniqueStorage()._mTotalLength = nil}

  var mActiveStartSecond: UInt32 {
    get {return _storage._mActiveStartSecond ?? 0}
    set {_uniqueStorage()._mActiveStartSecond = newValue}
  }
  /// Returns true if `mActiveStartSecond` has been explicitly set.
  var hasMActiveStartSecond: Bool {return _storage._mActiveStartSecond != nil}
  /// Clears the value of `mActiveStartSecond`. Subsequent reads from it will return its default value.
  mutating func clearMActiveStartSecond() {_uniqueStorage()._mActiveStartSecond = nil}

  var mActiveHrCount: UInt32 {
    get {return _storage._mActiveHrCount ?? 0}
    set {_uniqueStorage()._mActiveHrCount = newValue}
  }
  /// Returns true if `mActiveHrCount` has been explicitly set.
  var hasMActiveHrCount: Bool {return _storage._mActiveHrCount != nil}
  /// Clears the value of `mActiveHrCount`. Subsequent reads from it will return its default value.
  mutating func clearMActiveHrCount() {_uniqueStorage()._mActiveHrCount = nil}

  var mActiveType: UInt32 {
    get {return _storage._mActiveType ?? 0}
    set {_uniqueStorage()._mActiveType = newValue}
  }
  /// Returns true if `mActiveType` has been explicitly set.
  var hasMActiveType: Bool {return _storage._mActiveType != nil}
  /// Clears the value of `mActiveType`. Subsequent reads from it will return its default value.
  mutating func clearMActiveType() {_uniqueStorage()._mActiveType = nil}

  var mActiveStep: UInt32 {
    get {return _storage._mActiveStep ?? 0}
    set {_uniqueStorage()._mActiveStep = newValue}
  }
  /// Returns true if `mActiveStep` has been explicitly set.
  var hasMActiveStep: Bool {return _storage._mActiveStep != nil}
  /// Clears the value of `mActiveStep`. Subsequent reads from it will return its default value.
  mutating func clearMActiveStep() {_uniqueStorage()._mActiveStep = nil}

  var mActiveDurations: UInt32 {
    get {return _storage._mActiveDurations ?? 0}
    set {_uniqueStorage()._mActiveDurations = newValue}
  }
  /// Returns true if `mActiveDurations` has been explicitly set.
  var hasMActiveDurations: Bool {return _storage._mActiveDurations != nil}
  /// Clears the value of `mActiveDurations`. Subsequent reads from it will return its default value.
  mutating func clearMActiveDurations() {_uniqueStorage()._mActiveDurations = nil}

  var mActiveCalories: UInt32 {
    get {return _storage._mActiveCalories ?? 0}
    set {_uniqueStorage()._mActiveCalories = newValue}
  }
  /// Returns true if `mActiveCalories` has been explicitly set.
  var hasMActiveCalories: Bool {return _storage._mActiveCalories != nil}
  /// Clears the value of `mActiveCalories`. Subsequent reads from it will return its default value.
  mutating func clearMActiveCalories() {_uniqueStorage()._mActiveCalories = nil}

  var mActiveDistance: UInt32 {
    get {return _storage._mActiveDistance ?? 0}
    set {_uniqueStorage()._mActiveDistance = newValue}
  }
  /// Returns true if `mActiveDistance` has been explicitly set.
  var hasMActiveDistance: Bool {return _storage._mActiveDistance != nil}
  /// Clears the value of `mActiveDistance`. Subsequent reads from it will return its default value.
  mutating func clearMActiveDistance() {_uniqueStorage()._mActiveDistance = nil}

  var mActiveAvgHr: UInt32 {
    get {return _storage._mActiveAvgHr ?? 0}
    set {_uniqueStorage()._mActiveAvgHr = newValue}
  }
  /// Returns true if `mActiveAvgHr` has been explicitly set.
  var hasMActiveAvgHr: Bool {return _storage._mActiveAvgHr != nil}
  /// Clears the value of `mActiveAvgHr`. Subsequent reads from it will return its default value.
  mutating func clearMActiveAvgHr() {_uniqueStorage()._mActiveAvgHr = nil}

  var mActiveMaxHr: UInt32 {
    get {return _storage._mActiveMaxHr ?? 0}
    set {_uniqueStorage()._mActiveMaxHr = newValue}
  }
  /// Returns true if `mActiveMaxHr` has been explicitly set.
  var hasMActiveMaxHr: Bool {return _storage._mActiveMaxHr != nil}
  /// Clears the value of `mActiveMaxHr`. Subsequent reads from it will return its default value.
  mutating func clearMActiveMaxHr() {_uniqueStorage()._mActiveMaxHr = nil}

  var mBurnFatMins: UInt32 {
    get {return _storage._mBurnFatMins ?? 0}
    set {_uniqueStorage()._mBurnFatMins = newValue}
  }
  /// Returns true if `mBurnFatMins` has been explicitly set.
  var hasMBurnFatMins: Bool {return _storage._mBurnFatMins != nil}
  /// Clears the value of `mBurnFatMins`. Subsequent reads from it will return its default value.
  mutating func clearMBurnFatMins() {_uniqueStorage()._mBurnFatMins = nil}

  var mAerobicMins: UInt32 {
    get {return _storage._mAerobicMins ?? 0}
    set {_uniqueStorage()._mAerobicMins = newValue}
  }
  /// Returns true if `mAerobicMins` has been explicitly set.
  var hasMAerobicMins: Bool {return _storage._mAerobicMins != nil}
  /// Clears the value of `mAerobicMins`. Subsequent reads from it will return its default value.
  mutating func clearMAerobicMins() {_uniqueStorage()._mAerobicMins = nil}

  var mLimitMins: UInt32 {
    get {return _storage._mLimitMins ?? 0}
    set {_uniqueStorage()._mLimitMins = newValue}
  }
  /// Returns true if `mLimitMins` has been explicitly set.
  var hasMLimitMins: Bool {return _storage._mLimitMins != nil}
  /// Clears the value of `mLimitMins`. Subsequent reads from it will return its default value.
  mutating func clearMLimitMins() {_uniqueStorage()._mLimitMins = nil}

  var mIsEffective: UInt32 {
    get {return _storage._mIsEffective ?? 0}
    set {_uniqueStorage()._mIsEffective = newValue}
  }
  /// Returns true if `mIsEffective` has been explicitly set.
  var hasMIsEffective: Bool {return _storage._mIsEffective != nil}
  /// Clears the value of `mIsEffective`. Subsequent reads from it will return its default value.
  mutating func clearMIsEffective() {_uniqueStorage()._mIsEffective = nil}

  var mMagicNum: UInt32 {
    get {return _storage._mMagicNum ?? 0}
    set {_uniqueStorage()._mMagicNum = newValue}
  }
  /// Returns true if `mMagicNum` has been explicitly set.
  var hasMMagicNum: Bool {return _storage._mMagicNum != nil}
  /// Clears the value of `mMagicNum`. Subsequent reads from it will return its default value.
  mutating func clearMMagicNum() {_uniqueStorage()._mMagicNum = nil}

  var mSn: UInt32 {
    get {return _storage._mSn ?? 0}
    set {_uniqueStorage()._mSn = newValue}
  }
  /// Returns true if `mSn` has been explicitly set.
  var hasMSn: Bool {return _storage._mSn != nil}
  /// Clears the value of `mSn`. Subsequent reads from it will return its default value.
  mutating func clearMSn() {_uniqueStorage()._mSn = nil}

  var mHrData: Data {
    get {return _storage._mHrData ?? Data()}
    set {_uniqueStorage()._mHrData = newValue}
  }
  /// Returns true if `mHrData` has been explicitly set.
  var hasMHrData: Bool {return _storage._mHrData != nil}
  /// Clears the value of `mHrData`. Subsequent reads from it will return its default value.
  mutating func clearMHrData() {_uniqueStorage()._mHrData = nil}

  var mActiveSpeed: UInt32 {
    get {return _storage._mActiveSpeed ?? 0}
    set {_uniqueStorage()._mActiveSpeed = newValue}
  }
  /// Returns true if `mActiveSpeed` has been explicitly set.
  var hasMActiveSpeed: Bool {return _storage._mActiveSpeed != nil}
  /// Clears the value of `mActiveSpeed`. Subsequent reads from it will return its default value.
  mutating func clearMActiveSpeed() {_uniqueStorage()._mActiveSpeed = nil}

  var mActiveSwing: UInt32 {
    get {return _storage._mActiveSwing ?? 0}
    set {_uniqueStorage()._mActiveSwing = newValue}
  }
  /// Returns true if `mActiveSwing` has been explicitly set.
  var hasMActiveSwing: Bool {return _storage._mActiveSwing != nil}
  /// Clears the value of `mActiveSwing`. Subsequent reads from it will return its default value.
  mutating func clearMActiveSwing() {_uniqueStorage()._mActiveSwing = nil}

  var mActiveMinHr: UInt32 {
    get {return _storage._mActiveMinHr ?? 0}
    set {_uniqueStorage()._mActiveMinHr = newValue}
  }
  /// Returns true if `mActiveMinHr` has been explicitly set.
  var hasMActiveMinHr: Bool {return _storage._mActiveMinHr != nil}
  /// Clears the value of `mActiveMinHr`. Subsequent reads from it will return its default value.
  mutating func clearMActiveMinHr() {_uniqueStorage()._mActiveMinHr = nil}

  var mActiveSkipTimes: UInt32 {
    get {return _storage._mActiveSkipTimes ?? 0}
    set {_uniqueStorage()._mActiveSkipTimes = newValue}
  }
  /// Returns true if `mActiveSkipTimes` has been explicitly set.
  var hasMActiveSkipTimes: Bool {return _storage._mActiveSkipTimes != nil}
  /// Clears the value of `mActiveSkipTimes`. Subsequent reads from it will return its default value.
  mutating func clearMActiveSkipTimes() {_uniqueStorage()._mActiveSkipTimes = nil}

  var mActiveGpsCount: UInt32 {
    get {return _storage._mActiveGpsCount ?? 0}
    set {_uniqueStorage()._mActiveGpsCount = newValue}
  }
  /// Returns true if `mActiveGpsCount` has been explicitly set.
  var hasMActiveGpsCount: Bool {return _storage._mActiveGpsCount != nil}
  /// Clears the value of `mActiveGpsCount`. Subsequent reads from it will return its default value.
  mutating func clearMActiveGpsCount() {_uniqueStorage()._mActiveGpsCount = nil}

  var mTotalGpsNum: UInt32 {
    get {return _storage._mTotalGpsNum ?? 0}
    set {_uniqueStorage()._mTotalGpsNum = newValue}
  }
  /// Returns true if `mTotalGpsNum` has been explicitly set.
  var hasMTotalGpsNum: Bool {return _storage._mTotalGpsNum != nil}
  /// Clears the value of `mTotalGpsNum`. Subsequent reads from it will return its default value.
  mutating func clearMTotalGpsNum() {_uniqueStorage()._mTotalGpsNum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct r_get_ui_hrs_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mUiActHr: UInt32 {
    get {return _mUiActHr ?? 0}
    set {_mUiActHr = newValue}
  }
  /// Returns true if `mUiActHr` has been explicitly set.
  var hasMUiActHr: Bool {return self._mUiActHr != nil}
  /// Clears the value of `mUiActHr`. Subsequent reads from it will return its default value.
  mutating func clearMUiActHr() {self._mUiActHr = nil}

  var mUiMaxHr: UInt32 {
    get {return _mUiMaxHr ?? 0}
    set {_mUiMaxHr = newValue}
  }
  /// Returns true if `mUiMaxHr` has been explicitly set.
  var hasMUiMaxHr: Bool {return self._mUiMaxHr != nil}
  /// Clears the value of `mUiMaxHr`. Subsequent reads from it will return its default value.
  mutating func clearMUiMaxHr() {self._mUiMaxHr = nil}

  var mUiMinHr: UInt32 {
    get {return _mUiMinHr ?? 0}
    set {_mUiMinHr = newValue}
  }
  /// Returns true if `mUiMinHr` has been explicitly set.
  var hasMUiMinHr: Bool {return self._mUiMinHr != nil}
  /// Clears the value of `mUiMinHr`. Subsequent reads from it will return its default value.
  mutating func clearMUiMinHr() {self._mUiMinHr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mUiActHr: UInt32? = nil
  fileprivate var _mUiMaxHr: UInt32? = nil
  fileprivate var _mUiMinHr: UInt32? = nil
}

public struct set_nfc_operate_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mNfcOperateCode: UInt32 {
    get {return _mNfcOperateCode ?? 0}
    set {_mNfcOperateCode = newValue}
  }
  /// Returns true if `mNfcOperateCode` has been explicitly set.
  var hasMNfcOperateCode: Bool {return self._mNfcOperateCode != nil}
  /// Clears the value of `mNfcOperateCode`. Subsequent reads from it will return its default value.
  mutating func clearMNfcOperateCode() {self._mNfcOperateCode = nil}

  var mNfcData: Data {
    get {return _mNfcData ?? Data()}
    set {_mNfcData = newValue}
  }
  /// Returns true if `mNfcData` has been explicitly set.
    public  var hasMNfcData: Bool {return self._mNfcData != nil}
  /// Clears the value of `mNfcData`. Subsequent reads from it will return its default value.
  mutating func clearMNfcData() {self._mNfcData = nil}

  var mNfcErrCode: UInt32 {
    get {return _mNfcErrCode ?? 0}
    set {_mNfcErrCode = newValue}
  }
  /// Returns true if `mNfcErrCode` has been explicitly set.
  var hasMNfcErrCode: Bool {return self._mNfcErrCode != nil}
  /// Clears the value of `mNfcErrCode`. Subsequent reads from it will return its default value.
  mutating func clearMNfcErrCode() {self._mNfcErrCode = nil}

  var mNfcSubOperateCode: UInt32 {
    get {return _mNfcSubOperateCode ?? 0}
    set {_mNfcSubOperateCode = newValue}
  }
  /// Returns true if `mNfcSubOperateCode` has been explicitly set.
  var hasMNfcSubOperateCode: Bool {return self._mNfcSubOperateCode != nil}
  /// Clears the value of `mNfcSubOperateCode`. Subsequent reads from it will return its default value.
  mutating func clearMNfcSubOperateCode() {self._mNfcSubOperateCode = nil}

  var mNfcCity: UInt64 {
    get {return _mNfcCity ?? 0}
    set {_mNfcCity = newValue}
  }
  /// Returns true if `mNfcCity` has been explicitly set.
  var hasMNfcCity: Bool {return self._mNfcCity != nil}
  /// Clears the value of `mNfcCity`. Subsequent reads from it will return its default value.
  mutating func clearMNfcCity() {self._mNfcCity = nil}

    public  var unknownFields = SwiftProtobuf.UnknownStorage()

    public  init() {}

  fileprivate var _mNfcOperateCode: UInt32? = nil
  fileprivate var _mNfcData: Data? = nil
  fileprivate var _mNfcErrCode: UInt32? = nil
  fileprivate var _mNfcSubOperateCode: UInt32? = nil
  fileprivate var _mNfcCity: UInt64? = nil
}

struct set_page_switch_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mOperateType: UInt32 {
    get {return _mOperateType ?? 0}
    set {_mOperateType = newValue}
  }
  /// Returns true if `mOperateType` has been explicitly set.
  var hasMOperateType: Bool {return self._mOperateType != nil}
  /// Clears the value of `mOperateType`. Subsequent reads from it will return its default value.
  mutating func clearMOperateType() {self._mOperateType = nil}

  var mPageSwitch: UInt32 {
    get {return _mPageSwitch ?? 0}
    set {_mPageSwitch = newValue}
  }
  /// Returns true if `mPageSwitch` has been explicitly set.
  var hasMPageSwitch: Bool {return self._mPageSwitch != nil}
  /// Clears the value of `mPageSwitch`. Subsequent reads from it will return its default value.
  mutating func clearMPageSwitch() {self._mPageSwitch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mOperateType: UInt32? = nil
  fileprivate var _mPageSwitch: UInt32? = nil
}

struct set_check_gps_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mCheckType: UInt32 {
    get {return _mCheckType ?? 0}
    set {_mCheckType = newValue}
  }
  /// Returns true if `mCheckType` has been explicitly set.
  var hasMCheckType: Bool {return self._mCheckType != nil}
  /// Clears the value of `mCheckType`. Subsequent reads from it will return its default value.
  mutating func clearMCheckType() {self._mCheckType = nil}

  var mFileNum: UInt32 {
    get {return _mFileNum ?? 0}
    set {_mFileNum = newValue}
  }
  /// Returns true if `mFileNum` has been explicitly set.
  var hasMFileNum: Bool {return self._mFileNum != nil}
  /// Clears the value of `mFileNum`. Subsequent reads from it will return its default value.
  mutating func clearMFileNum() {self._mFileNum = nil}

  var mSecond: UInt32 {
    get {return _mSecond ?? 0}
    set {_mSecond = newValue}
  }
  /// Returns true if `mSecond` has been explicitly set.
  var hasMSecond: Bool {return self._mSecond != nil}
  /// Clears the value of `mSecond`. Subsequent reads from it will return its default value.
  mutating func clearMSecond() {self._mSecond = nil}

  var mNewVersion: UInt32 {
    get {return _mNewVersion ?? 0}
    set {_mNewVersion = newValue}
  }
  /// Returns true if `mNewVersion` has been explicitly set.
  var hasMNewVersion: Bool {return self._mNewVersion != nil}
  /// Clears the value of `mNewVersion`. Subsequent reads from it will return its default value.
  mutating func clearMNewVersion() {self._mNewVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mCheckType: UInt32? = nil
  fileprivate var _mFileNum: UInt32? = nil
  fileprivate var _mSecond: UInt32? = nil
  fileprivate var _mNewVersion: UInt32? = nil
}

struct set_update_gps_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mFileName: UInt32 {
    get {return _mFileName ?? 0}
    set {_mFileName = newValue}
  }
  /// Returns true if `mFileName` has been explicitly set.
  var hasMFileName: Bool {return self._mFileName != nil}
  /// Clears the value of `mFileName`. Subsequent reads from it will return its default value.
  mutating func clearMFileName() {self._mFileName = nil}

  var mFileLength: UInt32 {
    get {return _mFileLength ?? 0}
    set {_mFileLength = newValue}
  }
  /// Returns true if `mFileLength` has been explicitly set.
  var hasMFileLength: Bool {return self._mFileLength != nil}
  /// Clears the value of `mFileLength`. Subsequent reads from it will return its default value.
  mutating func clearMFileLength() {self._mFileLength = nil}

  var mSn: UInt32 {
    get {return _mSn ?? 0}
    set {_mSn = newValue}
  }
  /// Returns true if `mSn` has been explicitly set.
  var hasMSn: Bool {return self._mSn != nil}
  /// Clears the value of `mSn`. Subsequent reads from it will return its default value.
  mutating func clearMSn() {self._mSn = nil}

  var mData: Data {
    get {return _mData ?? Data()}
    set {_mData = newValue}
  }
  /// Returns true if `mData` has been explicitly set.
  var hasMData: Bool {return self._mData != nil}
  /// Clears the value of `mData`. Subsequent reads from it will return its default value.
  mutating func clearMData() {self._mData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mFileName: UInt32? = nil
  fileprivate var _mFileLength: UInt32? = nil
  fileprivate var _mSn: UInt32? = nil
  fileprivate var _mData: Data? = nil
}

struct set_update_spo2_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mSpo2Value: UInt32 {
    get {return _mSpo2Value ?? 0}
    set {_mSpo2Value = newValue}
  }
  /// Returns true if `mSpo2Value` has been explicitly set.
  var hasMSpo2Value: Bool {return self._mSpo2Value != nil}
  /// Clears the value of `mSpo2Value`. Subsequent reads from it will return its default value.
  mutating func clearMSpo2Value() {self._mSpo2Value = nil}

  var mSeconds: UInt32 {
    get {return _mSeconds ?? 0}
    set {_mSeconds = newValue}
  }
  /// Returns true if `mSeconds` has been explicitly set.
  var hasMSeconds: Bool {return self._mSeconds != nil}
  /// Clears the value of `mSeconds`. Subsequent reads from it will return its default value.
  mutating func clearMSeconds() {self._mSeconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mSpo2Value: UInt32? = nil
  fileprivate var _mSeconds: UInt32? = nil
}

struct get_dial_config_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mDialID: UInt32 {
    get {return _mDialID ?? 0}
    set {_mDialID = newValue}
  }
  /// Returns true if `mDialID` has been explicitly set.
  var hasMDialID: Bool {return self._mDialID != nil}
  /// Clears the value of `mDialID`. Subsequent reads from it will return its default value.
  mutating func clearMDialID() {self._mDialID = nil}

  var mDialWidth: UInt32 {
    get {return _mDialWidth ?? 0}
    set {_mDialWidth = newValue}
  }
  /// Returns true if `mDialWidth` has been explicitly set.
  var hasMDialWidth: Bool {return self._mDialWidth != nil}
  /// Clears the value of `mDialWidth`. Subsequent reads from it will return its default value.
  mutating func clearMDialWidth() {self._mDialWidth = nil}

  var mDialHeight: UInt32 {
    get {return _mDialHeight ?? 0}
    set {_mDialHeight = newValue}
  }
  /// Returns true if `mDialHeight` has been explicitly set.
  var hasMDialHeight: Bool {return self._mDialHeight != nil}
  /// Clears the value of `mDialHeight`. Subsequent reads from it will return its default value.
  mutating func clearMDialHeight() {self._mDialHeight = nil}

  var mDialForm: UInt32 {
    get {return _mDialForm ?? 0}
    set {_mDialForm = newValue}
  }
  /// Returns true if `mDialForm` has been explicitly set.
  var hasMDialForm: Bool {return self._mDialForm != nil}
  /// Clears the value of `mDialForm`. Subsequent reads from it will return its default value.
  mutating func clearMDialForm() {self._mDialForm = nil}

  var mDialMaxSize: UInt32 {
    get {return _mDialMaxSize ?? 0}
    set {_mDialMaxSize = newValue}
  }
  /// Returns true if `mDialMaxSize` has been explicitly set.
  var hasMDialMaxSize: Bool {return self._mDialMaxSize != nil}
  /// Clears the value of `mDialMaxSize`. Subsequent reads from it will return its default value.
  mutating func clearMDialMaxSize() {self._mDialMaxSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mDialID: UInt32? = nil
  fileprivate var _mDialWidth: UInt32? = nil
  fileprivate var _mDialHeight: UInt32? = nil
  fileprivate var _mDialForm: UInt32? = nil
  fileprivate var _mDialMaxSize: UInt32? = nil
}

struct set_warming_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mType: UInt32 {
    get {return _mType ?? 0}
    set {_mType = newValue}
  }
  /// Returns true if `mType` has been explicitly set.
  var hasMType: Bool {return self._mType != nil}
  /// Clears the value of `mType`. Subsequent reads from it will return its default value.
  mutating func clearMType() {self._mType = nil}

  var mMin: UInt32 {
    get {return _mMin ?? 0}
    set {_mMin = newValue}
  }
  /// Returns true if `mMin` has been explicitly set.
  var hasMMin: Bool {return self._mMin != nil}
  /// Clears the value of `mMin`. Subsequent reads from it will return its default value.
  mutating func clearMMin() {self._mMin = nil}

  var mMax: UInt32 {
    get {return _mMax ?? 0}
    set {_mMax = newValue}
  }
  /// Returns true if `mMax` has been explicitly set.
  var hasMMax: Bool {return self._mMax != nil}
  /// Clears the value of `mMax`. Subsequent reads from it will return its default value.
  mutating func clearMMax() {self._mMax = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mType: UInt32? = nil
  fileprivate var _mMin: UInt32? = nil
  fileprivate var _mMax: UInt32? = nil
}

struct set_menu_sequence_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mType: UInt32 {
    get {return _mType ?? 0}
    set {_mType = newValue}
  }
  /// Returns true if `mType` has been explicitly set.
  var hasMType: Bool {return self._mType != nil}
  /// Clears the value of `mType`. Subsequent reads from it will return its default value.
  mutating func clearMType() {self._mType = nil}

  var mCount: UInt32 {
    get {return _mCount ?? 0}
    set {_mCount = newValue}
  }
  /// Returns true if `mCount` has been explicitly set.
  var hasMCount: Bool {return self._mCount != nil}
  /// Clears the value of `mCount`. Subsequent reads from it will return its default value.
  mutating func clearMCount() {self._mCount = nil}

  var mData: Data {
    get {return _mData ?? Data()}
    set {_mData = newValue}
  }
  /// Returns true if `mData` has been explicitly set.
  var hasMData: Bool {return self._mData != nil}
  /// Clears the value of `mData`. Subsequent reads from it will return its default value.
  mutating func clearMData() {self._mData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mType: UInt32? = nil
  fileprivate var _mCount: UInt32? = nil
  fileprivate var _mData: Data? = nil
}

struct get_menu_sequence_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mType: UInt32 {
    get {return _mType ?? 0}
    set {_mType = newValue}
  }
  /// Returns true if `mType` has been explicitly set.
  var hasMType: Bool {return self._mType != nil}
  /// Clears the value of `mType`. Subsequent reads from it will return its default value.
  mutating func clearMType() {self._mType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mType: UInt32? = nil
}

struct r_get_menu_sequence_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mType: UInt32 {
    get {return _mType ?? 0}
    set {_mType = newValue}
  }
  /// Returns true if `mType` has been explicitly set.
  var hasMType: Bool {return self._mType != nil}
  /// Clears the value of `mType`. Subsequent reads from it will return its default value.
  mutating func clearMType() {self._mType = nil}

  var mSupportCount: UInt32 {
    get {return _mSupportCount ?? 0}
    set {_mSupportCount = newValue}
  }
  /// Returns true if `mSupportCount` has been explicitly set.
  var hasMSupportCount: Bool {return self._mSupportCount != nil}
  /// Clears the value of `mSupportCount`. Subsequent reads from it will return its default value.
  mutating func clearMSupportCount() {self._mSupportCount = nil}

  var mSupport: UInt32 {
    get {return _mSupport ?? 0}
    set {_mSupport = newValue}
  }
  /// Returns true if `mSupport` has been explicitly set.
  var hasMSupport: Bool {return self._mSupport != nil}
  /// Clears the value of `mSupport`. Subsequent reads from it will return its default value.
  mutating func clearMSupport() {self._mSupport = nil}

  var mCount: UInt32 {
    get {return _mCount ?? 0}
    set {_mCount = newValue}
  }
  /// Returns true if `mCount` has been explicitly set.
  var hasMCount: Bool {return self._mCount != nil}
  /// Clears the value of `mCount`. Subsequent reads from it will return its default value.
  mutating func clearMCount() {self._mCount = nil}

  var mData: Data {
    get {return _mData ?? Data()}
    set {_mData = newValue}
  }
  /// Returns true if `mData` has been explicitly set.
  var hasMData: Bool {return self._mData != nil}
  /// Clears the value of `mData`. Subsequent reads from it will return its default value.
  mutating func clearMData() {self._mData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mType: UInt32? = nil
  fileprivate var _mSupportCount: UInt32? = nil
  fileprivate var _mSupport: UInt32? = nil
  fileprivate var _mCount: UInt32? = nil
  fileprivate var _mData: Data? = nil
}

struct get_nfc_card_data_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mData: Data {
    get {return _mData ?? Data()}
    set {_mData = newValue}
  }
  /// Returns true if `mData` has been explicitly set.
  var hasMData: Bool {return self._mData != nil}
  /// Clears the value of `mData`. Subsequent reads from it will return its default value.
  mutating func clearMData() {self._mData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mData: Data? = nil
}

struct set_spo2_detect_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mNightEnable: UInt32 {
    get {return _mNightEnable ?? 0}
    set {_mNightEnable = newValue}
  }
  /// Returns true if `mNightEnable` has been explicitly set.
  var hasMNightEnable: Bool {return self._mNightEnable != nil}
  /// Clears the value of `mNightEnable`. Subsequent reads from it will return its default value.
  mutating func clearMNightEnable() {self._mNightEnable = nil}

  var mNightIntersec: UInt32 {
    get {return _mNightIntersec ?? 0}
    set {_mNightIntersec = newValue}
  }
  /// Returns true if `mNightIntersec` has been explicitly set.
  var hasMNightIntersec: Bool {return self._mNightIntersec != nil}
  /// Clears the value of `mNightIntersec`. Subsequent reads from it will return its default value.
  mutating func clearMNightIntersec() {self._mNightIntersec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mNightEnable: UInt32? = nil
  fileprivate var _mNightIntersec: UInt32? = nil
}

struct r_get_spo2_detect_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mNightEnable: UInt32 {
    get {return _mNightEnable ?? 0}
    set {_mNightEnable = newValue}
  }
  /// Returns true if `mNightEnable` has been explicitly set.
  var hasMNightEnable: Bool {return self._mNightEnable != nil}
  /// Clears the value of `mNightEnable`. Subsequent reads from it will return its default value.
  mutating func clearMNightEnable() {self._mNightEnable = nil}

  var mNightIntersec: UInt32 {
    get {return _mNightIntersec ?? 0}
    set {_mNightIntersec = newValue}
  }
  /// Returns true if `mNightIntersec` has been explicitly set.
  var hasMNightIntersec: Bool {return self._mNightIntersec != nil}
  /// Clears the value of `mNightIntersec`. Subsequent reads from it will return its default value.
  mutating func clearMNightIntersec() {self._mNightIntersec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mNightEnable: UInt32? = nil
  fileprivate var _mNightIntersec: UInt32? = nil
}

struct swsn_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var swsn: Data {
    get {return _swsn ?? Data()}
    set {_swsn = newValue}
  }
  /// Returns true if `swsn` has been explicitly set.
  var hasSwsn: Bool {return self._swsn != nil}
  /// Clears the value of `swsn`. Subsequent reads from it will return its default value.
  mutating func clearSwsn() {self._swsn = nil}

  var funcSwitch: UInt32 {
    get {return _funcSwitch ?? 0}
    set {_funcSwitch = newValue}
  }
  /// Returns true if `funcSwitch` has been explicitly set.
  var hasFuncSwitch: Bool {return self._funcSwitch != nil}
  /// Clears the value of `funcSwitch`. Subsequent reads from it will return its default value.
  mutating func clearFuncSwitch() {self._funcSwitch = nil}

  var langsSwitch: UInt32 {
    get {return _langsSwitch ?? 0}
    set {_langsSwitch = newValue}
  }
  /// Returns true if `langsSwitch` has been explicitly set.
  var hasLangsSwitch: Bool {return self._langsSwitch != nil}
  /// Clears the value of `langsSwitch`. Subsequent reads from it will return its default value.
  mutating func clearLangsSwitch() {self._langsSwitch = nil}

  var defaultLang: UInt32 {
    get {return _defaultLang ?? 0}
    set {_defaultLang = newValue}
  }
  /// Returns true if `defaultLang` has been explicitly set.
  var hasDefaultLang: Bool {return self._defaultLang != nil}
  /// Clears the value of `defaultLang`. Subsequent reads from it will return its default value.
  mutating func clearDefaultLang() {self._defaultLang = nil}

  var projectNum: UInt32 {
    get {return _projectNum ?? 0}
    set {_projectNum = newValue}
  }
  /// Returns true if `projectNum` has been explicitly set.
  var hasProjectNum: Bool {return self._projectNum != nil}
  /// Clears the value of `projectNum`. Subsequent reads from it will return its default value.
  mutating func clearProjectNum() {self._projectNum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _swsn: Data? = nil
  fileprivate var _funcSwitch: UInt32? = nil
  fileprivate var _langsSwitch: UInt32? = nil
  fileprivate var _defaultLang: UInt32? = nil
  fileprivate var _projectNum: UInt32? = nil
}

struct set_phone_app_status_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mStatus: UInt32 {
    get {return _mStatus ?? 0}
    set {_mStatus = newValue}
  }
  /// Returns true if `mStatus` has been explicitly set.
  var hasMStatus: Bool {return self._mStatus != nil}
  /// Clears the value of `mStatus`. Subsequent reads from it will return its default value.
  mutating func clearMStatus() {self._mStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mStatus: UInt32? = nil
}

struct set_female_health_info_t {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mDuration: UInt32 {
    get {return _mDuration ?? 0}
    set {_mDuration = newValue}
  }
  /// Returns true if `mDuration` has been explicitly set.
  var hasMDuration: Bool {return self._mDuration != nil}
  /// Clears the value of `mDuration`. Subsequent reads from it will return its default value.
  mutating func clearMDuration() {self._mDuration = nil}

  var mPeriod: UInt32 {
    get {return _mPeriod ?? 0}
    set {_mPeriod = newValue}
  }
  /// Returns true if `mPeriod` has been explicitly set.
  var hasMPeriod: Bool {return self._mPeriod != nil}
  /// Clears the value of `mPeriod`. Subsequent reads from it will return its default value.
  mutating func clearMPeriod() {self._mPeriod = nil}

  var mLastYear: UInt32 {
    get {return _mLastYear ?? 0}
    set {_mLastYear = newValue}
  }
  /// Returns true if `mLastYear` has been explicitly set.
  var hasMLastYear: Bool {return self._mLastYear != nil}
  /// Clears the value of `mLastYear`. Subsequent reads from it will return its default value.
  mutating func clearMLastYear() {self._mLastYear = nil}

  var mLastMonth: UInt32 {
    get {return _mLastMonth ?? 0}
    set {_mLastMonth = newValue}
  }
  /// Returns true if `mLastMonth` has been explicitly set.
  var hasMLastMonth: Bool {return self._mLastMonth != nil}
  /// Clears the value of `mLastMonth`. Subsequent reads from it will return its default value.
  mutating func clearMLastMonth() {self._mLastMonth = nil}

  var mLastDay: UInt32 {
    get {return _mLastDay ?? 0}
    set {_mLastDay = newValue}
  }
  /// Returns true if `mLastDay` has been explicitly set.
  var hasMLastDay: Bool {return self._mLastDay != nil}
  /// Clears the value of `mLastDay`. Subsequent reads from it will return its default value.
  mutating func clearMLastDay() {self._mLastDay = nil}

  var mSetTimestamps: UInt32 {
    get {return _mSetTimestamps ?? 0}
    set {_mSetTimestamps = newValue}
  }
  /// Returns true if `mSetTimestamps` has been explicitly set.
  var hasMSetTimestamps: Bool {return self._mSetTimestamps != nil}
  /// Clears the value of `mSetTimestamps`. Subsequent reads from it will return its default value.
  mutating func clearMSetTimestamps() {self._mSetTimestamps = nil}

  var mSetYear: UInt32 {
    get {return _mSetYear ?? 0}
    set {_mSetYear = newValue}
  }
  /// Returns true if `mSetYear` has been explicitly set.
  var hasMSetYear: Bool {return self._mSetYear != nil}
  /// Clears the value of `mSetYear`. Subsequent reads from it will return its default value.
  mutating func clearMSetYear() {self._mSetYear = nil}

  var mSetMonth: UInt32 {
    get {return _mSetMonth ?? 0}
    set {_mSetMonth = newValue}
  }
  /// Returns true if `mSetMonth` has been explicitly set.
  var hasMSetMonth: Bool {return self._mSetMonth != nil}
  /// Clears the value of `mSetMonth`. Subsequent reads from it will return its default value.
  mutating func clearMSetMonth() {self._mSetMonth = nil}

  var mSetDay: UInt32 {
    get {return _mSetDay ?? 0}
    set {_mSetDay = newValue}
  }
  /// Returns true if `mSetDay` has been explicitly set.
  var hasMSetDay: Bool {return self._mSetDay != nil}
  /// Clears the value of `mSetDay`. Subsequent reads from it will return its default value.
  mutating func clearMSetDay() {self._mSetDay = nil}

  var mCheck: UInt32 {
    get {return _mCheck ?? 0}
    set {_mCheck = newValue}
  }
  /// Returns true if `mCheck` has been explicitly set.
  var hasMCheck: Bool {return self._mCheck != nil}
  /// Clears the value of `mCheck`. Subsequent reads from it will return its default value.
  mutating func clearMCheck() {self._mCheck = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mDuration: UInt32? = nil
  fileprivate var _mPeriod: UInt32? = nil
  fileprivate var _mLastYear: UInt32? = nil
  fileprivate var _mLastMonth: UInt32? = nil
  fileprivate var _mLastDay: UInt32? = nil
  fileprivate var _mSetTimestamps: UInt32? = nil
  fileprivate var _mSetYear: UInt32? = nil
  fileprivate var _mSetMonth: UInt32? = nil
  fileprivate var _mSetDay: UInt32? = nil
  fileprivate var _mCheck: UInt32? = nil
}

///***********************app or fw send cmd****************/
public struct hl_cmds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///cmd
  var cmd: hl_cmds.cmd_t {
    get {return _storage._cmd ?? .cmdBindDevice}
    set {_uniqueStorage()._cmd = newValue}
  }
  /// Returns true if `cmd` has been explicitly set.
  var hasCmd: Bool {return _storage._cmd != nil}
  /// Clears the value of `cmd`. Subsequent reads from it will return its default value.
  mutating func clearCmd() {_uniqueStorage()._cmd = nil}

  var response: Bool {
    get {return _storage._response ?? false}
    set {_uniqueStorage()._response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return _storage._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {_uniqueStorage()._response = nil}

  var seconds: UInt32 {
    get {return _storage._seconds ?? 0}
    set {_uniqueStorage()._seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  var hasSeconds: Bool {return _storage._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  mutating func clearSeconds() {_uniqueStorage()._seconds = nil}

  var timezone: Int32 {
    get {return _storage._timezone ?? 0}
    set {_uniqueStorage()._timezone = newValue}
  }
  /// Returns true if `timezone` has been explicitly set.
  var hasTimezone: Bool {return _storage._timezone != nil}
  /// Clears the value of `timezone`. Subsequent reads from it will return its default value.
  mutating func clearTimezone() {_uniqueStorage()._timezone = nil}

  var setAppInfo: bind_app_info_t {
    get {return _storage._setAppInfo ?? bind_app_info_t()}
    set {_uniqueStorage()._setAppInfo = newValue}
  }
  /// Returns true if `setAppInfo` has been explicitly set.
  var hasSetAppInfo: Bool {return _storage._setAppInfo != nil}
  /// Clears the value of `setAppInfo`. Subsequent reads from it will return its default value.
  mutating func clearSetAppInfo() {_uniqueStorage()._setAppInfo = nil}

  var rBindDevice: r_bind_device_t {
    get {return _storage._rBindDevice ?? r_bind_device_t()}
    set {_uniqueStorage()._rBindDevice = newValue}
  }
  /// Returns true if `rBindDevice` has been explicitly set.
  var hasRBindDevice: Bool {return _storage._rBindDevice != nil}
  /// Clears the value of `rBindDevice`. Subsequent reads from it will return its default value.
  mutating func clearRBindDevice() {_uniqueStorage()._rBindDevice = nil}

  var rGetDeviceInfo: r_get_device_info_t {
    get {return _storage._rGetDeviceInfo ?? r_get_device_info_t()}
    set {_uniqueStorage()._rGetDeviceInfo = newValue}
  }
  /// Returns true if `rGetDeviceInfo` has been explicitly set.
  var hasRGetDeviceInfo: Bool {return _storage._rGetDeviceInfo != nil}
  /// Clears the value of `rGetDeviceInfo`. Subsequent reads from it will return its default value.
  mutating func clearRGetDeviceInfo() {_uniqueStorage()._rGetDeviceInfo = nil}

  var syncPhoneInfo: sync_phone_info_t {
    get {return _storage._syncPhoneInfo ?? sync_phone_info_t()}
    set {_uniqueStorage()._syncPhoneInfo = newValue}
  }
  /// Returns true if `syncPhoneInfo` has been explicitly set.
  var hasSyncPhoneInfo: Bool {return _storage._syncPhoneInfo != nil}
  /// Clears the value of `syncPhoneInfo`. Subsequent reads from it will return its default value.
  mutating func clearSyncPhoneInfo() {_uniqueStorage()._syncPhoneInfo = nil}

  var syncUserInfo: sync_user_info_t {
    get {return _storage._syncUserInfo ?? sync_user_info_t()}
    set {_uniqueStorage()._syncUserInfo = newValue}
  }
  /// Returns true if `syncUserInfo` has been explicitly set.
  var hasSyncUserInfo: Bool {return _storage._syncUserInfo != nil}
  /// Clears the value of `syncUserInfo`. Subsequent reads from it will return its default value.
  mutating func clearSyncUserInfo() {_uniqueStorage()._syncUserInfo = nil}

  var syncSwitch: sync_switch_t {
    get {return _storage._syncSwitch ?? sync_switch_t()}
    set {_uniqueStorage()._syncSwitch = newValue}
  }
  /// Returns true if `syncSwitch` has been explicitly set.
  var hasSyncSwitch: Bool {return _storage._syncSwitch != nil}
  /// Clears the value of `syncSwitch`. Subsequent reads from it will return its default value.
  mutating func clearSyncSwitch() {_uniqueStorage()._syncSwitch = nil}

  var setHrSampleSlot: set_hr_sample_slot_t {
    get {return _storage._setHrSampleSlot ?? set_hr_sample_slot_t()}
    set {_uniqueStorage()._setHrSampleSlot = newValue}
  }
  /// Returns true if `setHrSampleSlot` has been explicitly set.
  var hasSetHrSampleSlot: Bool {return _storage._setHrSampleSlot != nil}
  /// Clears the value of `setHrSampleSlot`. Subsequent reads from it will return its default value.
  mutating func clearSetHrSampleSlot() {_uniqueStorage()._setHrSampleSlot = nil}

  var setLongsitDuration: set_longsit_duration_t {
    get {return _storage._setLongsitDuration ?? set_longsit_duration_t()}
    set {_uniqueStorage()._setLongsitDuration = newValue}
  }
  /// Returns true if `setLongsitDuration` has been explicitly set.
  var hasSetLongsitDuration: Bool {return _storage._setLongsitDuration != nil}
  /// Clears the value of `setLongsitDuration`. Subsequent reads from it will return its default value.
  mutating func clearSetLongsitDuration() {_uniqueStorage()._setLongsitDuration = nil}

  var setDrinkSlot: set_drink_slot_t {
    get {return _storage._setDrinkSlot ?? set_drink_slot_t()}
    set {_uniqueStorage()._setDrinkSlot = newValue}
  }
  /// Returns true if `setDrinkSlot` has been explicitly set.
  var hasSetDrinkSlot: Bool {return _storage._setDrinkSlot != nil}
  /// Clears the value of `setDrinkSlot`. Subsequent reads from it will return its default value.
  mutating func clearSetDrinkSlot() {_uniqueStorage()._setDrinkSlot = nil}

  var setAlarms: set_alarms_t {
    get {return _storage._setAlarms ?? set_alarms_t()}
    set {_uniqueStorage()._setAlarms = newValue}
  }
  /// Returns true if `setAlarms` has been explicitly set.
  var hasSetAlarms: Bool {return _storage._setAlarms != nil}
  /// Clears the value of `setAlarms`. Subsequent reads from it will return its default value.
  mutating func clearSetAlarms() {_uniqueStorage()._setAlarms = nil}

  var setNotdisturb: set_notdisturb_t {
    get {return _storage._setNotdisturb ?? set_notdisturb_t()}
    set {_uniqueStorage()._setNotdisturb = newValue}
  }
  /// Returns true if `setNotdisturb` has been explicitly set.
  var hasSetNotdisturb: Bool {return _storage._setNotdisturb != nil}
  /// Clears the value of `setNotdisturb`. Subsequent reads from it will return its default value.
  mutating func clearSetNotdisturb() {_uniqueStorage()._setNotdisturb = nil}

  var setCountryInfo: set_country_info_t {
    get {return _storage._setCountryInfo ?? set_country_info_t()}
    set {_uniqueStorage()._setCountryInfo = newValue}
  }
  /// Returns true if `setCountryInfo` has been explicitly set.
  var hasSetCountryInfo: Bool {return _storage._setCountryInfo != nil}
  /// Clears the value of `setCountryInfo`. Subsequent reads from it will return its default value.
  mutating func clearSetCountryInfo() {_uniqueStorage()._setCountryInfo = nil}

  var setUiStyle: set_ui_style_t {
    get {return _storage._setUiStyle ?? set_ui_style_t()}
    set {_uniqueStorage()._setUiStyle = newValue}
  }
  /// Returns true if `setUiStyle` has been explicitly set.
  var hasSetUiStyle: Bool {return _storage._setUiStyle != nil}
  /// Clears the value of `setUiStyle`. Subsequent reads from it will return its default value.
  mutating func clearSetUiStyle() {_uniqueStorage()._setUiStyle = nil}

  var setSportTarget: set_sport_target_t {
    get {return _storage._setSportTarget ?? set_sport_target_t()}
    set {_uniqueStorage()._setSportTarget = newValue}
  }
  /// Returns true if `setSportTarget` has been explicitly set.
  var hasSetSportTarget: Bool {return _storage._setSportTarget != nil}
  /// Clears the value of `setSportTarget`. Subsequent reads from it will return its default value.
  mutating func clearSetSportTarget() {_uniqueStorage()._setSportTarget = nil}

  var setTimeFormat: set_time_format_t {
    get {return _storage._setTimeFormat ?? set_time_format_t()}
    set {_uniqueStorage()._setTimeFormat = newValue}
  }
  /// Returns true if `setTimeFormat` has been explicitly set.
  var hasSetTimeFormat: Bool {return _storage._setTimeFormat != nil}
  /// Clears the value of `setTimeFormat`. Subsequent reads from it will return its default value.
  mutating func clearSetTimeFormat() {_uniqueStorage()._setTimeFormat = nil}

  var setMetricInch: set_metric_inch_t {
    get {return _storage._setMetricInch ?? set_metric_inch_t()}
    set {_uniqueStorage()._setMetricInch = newValue}
  }
  /// Returns true if `setMetricInch` has been explicitly set.
  var hasSetMetricInch: Bool {return _storage._setMetricInch != nil}
  /// Clears the value of `setMetricInch`. Subsequent reads from it will return its default value.
  mutating func clearSetMetricInch() {_uniqueStorage()._setMetricInch = nil}

  var setBrightTimes: set_bright_times_t {
    get {return _storage._setBrightTimes ?? set_bright_times_t()}
    set {_uniqueStorage()._setBrightTimes = newValue}
  }
  /// Returns true if `setBrightTimes` has been explicitly set.
  var hasSetBrightTimes: Bool {return _storage._setBrightTimes != nil}
  /// Clears the value of `setBrightTimes`. Subsequent reads from it will return its default value.
  mutating func clearSetBrightTimes() {_uniqueStorage()._setBrightTimes = nil}

  var setSetHrWarning: set_hr_warning_t {
    get {return _storage._setSetHrWarning ?? set_hr_warning_t()}
    set {_uniqueStorage()._setSetHrWarning = newValue}
  }
  /// Returns true if `setSetHrWarning` has been explicitly set.
  var hasSetSetHrWarning: Bool {return _storage._setSetHrWarning != nil}
  /// Clears the value of `setSetHrWarning`. Subsequent reads from it will return its default value.
  mutating func clearSetSetHrWarning() {_uniqueStorage()._setSetHrWarning = nil}

  var rGetHrValue: r_get_hr_value_t {
    get {return _storage._rGetHrValue ?? r_get_hr_value_t()}
    set {_uniqueStorage()._rGetHrValue = newValue}
  }
  /// Returns true if `rGetHrValue` has been explicitly set.
  var hasRGetHrValue: Bool {return _storage._rGetHrValue != nil}
  /// Clears the value of `rGetHrValue`. Subsequent reads from it will return its default value.
  mutating func clearRGetHrValue() {_uniqueStorage()._rGetHrValue = nil}

  var setNotifyWarnInfo: set_notify_warning_t {
    get {return _storage._setNotifyWarnInfo ?? set_notify_warning_t()}
    set {_uniqueStorage()._setNotifyWarnInfo = newValue}
  }
  /// Returns true if `setNotifyWarnInfo` has been explicitly set.
  var hasSetNotifyWarnInfo: Bool {return _storage._setNotifyWarnInfo != nil}
  /// Clears the value of `setNotifyWarnInfo`. Subsequent reads from it will return its default value.
  mutating func clearSetNotifyWarnInfo() {_uniqueStorage()._setNotifyWarnInfo = nil}

  var setHealthDataInfo: r_sync_health_data_t {
    get {return _storage._setHealthDataInfo ?? r_sync_health_data_t()}
    set {_uniqueStorage()._setHealthDataInfo = newValue}
  }
  /// Returns true if `setHealthDataInfo` has been explicitly set.
  var hasSetHealthDataInfo: Bool {return _storage._setHealthDataInfo != nil}
  /// Clears the value of `setHealthDataInfo`. Subsequent reads from it will return its default value.
  mutating func clearSetHealthDataInfo() {_uniqueStorage()._setHealthDataInfo = nil}

  var rGetPowerValue: r_get_power_t {
    get {return _storage._rGetPowerValue ?? r_get_power_t()}
    set {_uniqueStorage()._rGetPowerValue = newValue}
  }
  /// Returns true if `rGetPowerValue` has been explicitly set.
  var hasRGetPowerValue: Bool {return _storage._rGetPowerValue != nil}
  /// Clears the value of `rGetPowerValue`. Subsequent reads from it will return its default value.
  mutating func clearRGetPowerValue() {_uniqueStorage()._rGetPowerValue = nil}

  var setUpdataFw: set_updata_fw_t {
    get {return _storage._setUpdataFw ?? set_updata_fw_t()}
    set {_uniqueStorage()._setUpdataFw = newValue}
  }
  /// Returns true if `setUpdataFw` has been explicitly set.
  var hasSetUpdataFw: Bool {return _storage._setUpdataFw != nil}
  /// Clears the value of `setUpdataFw`. Subsequent reads from it will return its default value.
  mutating func clearSetUpdataFw() {_uniqueStorage()._setUpdataFw = nil}

  var setWeatherInfo: set_weather_info_t {
    get {return _storage._setWeatherInfo ?? set_weather_info_t()}
    set {_uniqueStorage()._setWeatherInfo = newValue}
  }
  /// Returns true if `setWeatherInfo` has been explicitly set.
  var hasSetWeatherInfo: Bool {return _storage._setWeatherInfo != nil}
  /// Clears the value of `setWeatherInfo`. Subsequent reads from it will return its default value.
  mutating func clearSetWeatherInfo() {_uniqueStorage()._setWeatherInfo = nil}

  var setResetMachine: set_reset_machine_t {
    get {return _storage._setResetMachine ?? set_reset_machine_t()}
    set {_uniqueStorage()._setResetMachine = newValue}
  }
  /// Returns true if `setResetMachine` has been explicitly set.
  var hasSetResetMachine: Bool {return _storage._setResetMachine != nil}
  /// Clears the value of `setResetMachine`. Subsequent reads from it will return its default value.
  mutating func clearSetResetMachine() {_uniqueStorage()._setResetMachine = nil}

  var setSportStatus: set_sport_status_t {
    get {return _storage._setSportStatus ?? set_sport_status_t()}
    set {_uniqueStorage()._setSportStatus = newValue}
  }
  /// Returns true if `setSportStatus` has been explicitly set.
  var hasSetSportStatus: Bool {return _storage._setSportStatus != nil}
  /// Clears the value of `setSportStatus`. Subsequent reads from it will return its default value.
  mutating func clearSetSportStatus() {_uniqueStorage()._setSportStatus = nil}

  var rGetHealthData: r_get_health_data_t {
    get {return _storage._rGetHealthData ?? r_get_health_data_t()}
    set {_uniqueStorage()._rGetHealthData = newValue}
  }
  /// Returns true if `rGetHealthData` has been explicitly set.
  var hasRGetHealthData: Bool {return _storage._rGetHealthData != nil}
  /// Clears the value of `rGetHealthData`. Subsequent reads from it will return its default value.
  mutating func clearRGetHealthData() {_uniqueStorage()._rGetHealthData = nil}

  var setMusicInfo: set_music_info_t {
    get {return _storage._setMusicInfo ?? set_music_info_t()}
    set {_uniqueStorage()._setMusicInfo = newValue}
  }
  /// Returns true if `setMusicInfo` has been explicitly set.
  var hasSetMusicInfo: Bool {return _storage._setMusicInfo != nil}
  /// Clears the value of `setMusicInfo`. Subsequent reads from it will return its default value.
  mutating func clearSetMusicInfo() {_uniqueStorage()._setMusicInfo = nil}

  var rGetMtuSize: r_get_mtu_size_t {
    get {return _storage._rGetMtuSize ?? r_get_mtu_size_t()}
    set {_uniqueStorage()._rGetMtuSize = newValue}
  }
  /// Returns true if `rGetMtuSize` has been explicitly set.
  var hasRGetMtuSize: Bool {return _storage._rGetMtuSize != nil}
  /// Clears the value of `rGetMtuSize`. Subsequent reads from it will return its default value.
  mutating func clearRGetMtuSize() {_uniqueStorage()._rGetMtuSize = nil}

  var setBinData: set_bin_data_t {
    get {return _storage._setBinData ?? set_bin_data_t()}
    set {_uniqueStorage()._setBinData = newValue}
  }
  /// Returns true if `setBinData` has been explicitly set.
  var hasSetBinData: Bool {return _storage._setBinData != nil}
  /// Clears the value of `setBinData`. Subsequent reads from it will return its default value.
  mutating func clearSetBinData() {_uniqueStorage()._setBinData = nil}

  var setBigData: set_big_data_t {
    get {return _storage._setBigData ?? set_big_data_t()}
    set {_uniqueStorage()._setBigData = newValue}
  }
  /// Returns true if `setBigData` has been explicitly set.
  var hasSetBigData: Bool {return _storage._setBigData != nil}
  /// Clears the value of `setBigData`. Subsequent reads from it will return its default value.
  mutating func clearSetBigData() {_uniqueStorage()._setBigData = nil}

  var rFindPhone: r_find_phone_t {
    get {return _storage._rFindPhone ?? r_find_phone_t()}
    set {_uniqueStorage()._rFindPhone = newValue}
  }
  /// Returns true if `rFindPhone` has been explicitly set.
  var hasRFindPhone: Bool {return _storage._rFindPhone != nil}
  /// Clears the value of `rFindPhone`. Subsequent reads from it will return its default value.
  mutating func clearRFindPhone() {_uniqueStorage()._rFindPhone = nil}

  var setHrDur: set_rtimehr_dur_t {
    get {return _storage._setHrDur ?? set_rtimehr_dur_t()}
    set {_uniqueStorage()._setHrDur = newValue}
  }
  /// Returns true if `setHrDur` has been explicitly set.
  var hasSetHrDur: Bool {return _storage._setHrDur != nil}
  /// Clears the value of `setHrDur`. Subsequent reads from it will return its default value.
  mutating func clearSetHrDur() {_uniqueStorage()._setHrDur = nil}

  var rHrValue: r_rtimehr_value_t {
    get {return _storage._rHrValue ?? r_rtimehr_value_t()}
    set {_uniqueStorage()._rHrValue = newValue}
  }
  /// Returns true if `rHrValue` has been explicitly set.
  var hasRHrValue: Bool {return _storage._rHrValue != nil}
  /// Clears the value of `rHrValue`. Subsequent reads from it will return its default value.
  mutating func clearRHrValue() {_uniqueStorage()._rHrValue = nil}

  var rGetSprotData: r_get_sport_data_t {
    get {return _storage._rGetSprotData ?? r_get_sport_data_t()}
    set {_uniqueStorage()._rGetSprotData = newValue}
  }
  /// Returns true if `rGetSprotData` has been explicitly set.
  var hasRGetSprotData: Bool {return _storage._rGetSprotData != nil}
  /// Clears the value of `rGetSprotData`. Subsequent reads from it will return its default value.
  mutating func clearRGetSprotData() {_uniqueStorage()._rGetSprotData = nil}

  var rGetDisturbEn: r_get_disturb_en_t {
    get {return _storage._rGetDisturbEn ?? r_get_disturb_en_t()}
    set {_uniqueStorage()._rGetDisturbEn = newValue}
  }
  /// Returns true if `rGetDisturbEn` has been explicitly set.
  var hasRGetDisturbEn: Bool {return _storage._rGetDisturbEn != nil}
  /// Clears the value of `rGetDisturbEn`. Subsequent reads from it will return its default value.
  mutating func clearRGetDisturbEn() {_uniqueStorage()._rGetDisturbEn = nil}

  var rGetStepCount: r_get_step_count_t {
    get {return _storage._rGetStepCount ?? r_get_step_count_t()}
    set {_uniqueStorage()._rGetStepCount = newValue}
  }
  /// Returns true if `rGetStepCount` has been explicitly set.
  var hasRGetStepCount: Bool {return _storage._rGetStepCount != nil}
  /// Clears the value of `rGetStepCount`. Subsequent reads from it will return its default value.
  mutating func clearRGetStepCount() {_uniqueStorage()._rGetStepCount = nil}

  var rGetCurrentHr: r_get_current_hr_t {
    get {return _storage._rGetCurrentHr ?? r_get_current_hr_t()}
    set {_uniqueStorage()._rGetCurrentHr = newValue}
  }
  /// Returns true if `rGetCurrentHr` has been explicitly set.
  var hasRGetCurrentHr: Bool {return _storage._rGetCurrentHr != nil}
  /// Clears the value of `rGetCurrentHr`. Subsequent reads from it will return its default value.
  mutating func clearRGetCurrentHr() {_uniqueStorage()._rGetCurrentHr = nil}

  var rSetLightResult: r_set_light_leak_result_t {
    get {return _storage._rSetLightResult ?? r_set_light_leak_result_t()}
    set {_uniqueStorage()._rSetLightResult = newValue}
  }
  /// Returns true if `rSetLightResult` has been explicitly set.
  var hasRSetLightResult: Bool {return _storage._rSetLightResult != nil}
  /// Clears the value of `rSetLightResult`. Subsequent reads from it will return its default value.
  mutating func clearRSetLightResult() {_uniqueStorage()._rSetLightResult = nil}

  var rGetActiveRecord: r_get_active_record_data_t {
    get {return _storage._rGetActiveRecord ?? r_get_active_record_data_t()}
    set {_uniqueStorage()._rGetActiveRecord = newValue}
  }
  /// Returns true if `rGetActiveRecord` has been explicitly set.
  var hasRGetActiveRecord: Bool {return _storage._rGetActiveRecord != nil}
  /// Clears the value of `rGetActiveRecord`. Subsequent reads from it will return its default value.
  mutating func clearRGetActiveRecord() {_uniqueStorage()._rGetActiveRecord = nil}

  var rSetActiveInfo: r_set_active_info_t {
    get {return _storage._rSetActiveInfo ?? r_set_active_info_t()}
    set {_uniqueStorage()._rSetActiveInfo = newValue}
  }
  /// Returns true if `rSetActiveInfo` has been explicitly set.
  var hasRSetActiveInfo: Bool {return _storage._rSetActiveInfo != nil}
  /// Clears the value of `rSetActiveInfo`. Subsequent reads from it will return its default value.
  mutating func clearRSetActiveInfo() {_uniqueStorage()._rSetActiveInfo = nil}

  var rGetLogInfo: r_get_log_info_t {
    get {return _storage._rGetLogInfo ?? r_get_log_info_t()}
    set {_uniqueStorage()._rGetLogInfo = newValue}
  }
  /// Returns true if `rGetLogInfo` has been explicitly set.
  var hasRGetLogInfo: Bool {return _storage._rGetLogInfo != nil}
  /// Clears the value of `rGetLogInfo`. Subsequent reads from it will return its default value.
  mutating func clearRGetLogInfo() {_uniqueStorage()._rGetLogInfo = nil}

  var rGetUiHrs: r_get_ui_hrs_t {
    get {return _storage._rGetUiHrs ?? r_get_ui_hrs_t()}
    set {_uniqueStorage()._rGetUiHrs = newValue}
  }
  /// Returns true if `rGetUiHrs` has been explicitly set.
  var hasRGetUiHrs: Bool {return _storage._rGetUiHrs != nil}
  /// Clears the value of `rGetUiHrs`. Subsequent reads from it will return its default value.
  mutating func clearRGetUiHrs() {_uniqueStorage()._rGetUiHrs = nil}

  var rErrorCode: r_error_code_t {
    get {return _storage._rErrorCode ?? r_error_code_t()}
    set {_uniqueStorage()._rErrorCode = newValue}
  }
  /// Returns true if `rErrorCode` has been explicitly set.
  var hasRErrorCode: Bool {return _storage._rErrorCode != nil}
  /// Clears the value of `rErrorCode`. Subsequent reads from it will return its default value.
  mutating func clearRErrorCode() {_uniqueStorage()._rErrorCode = nil}

    public  var setNfcOperate: set_nfc_operate_t {
    get {return _storage._setNfcOperate ?? set_nfc_operate_t()}
    set {_uniqueStorage()._setNfcOperate = newValue}
  }
  /// Returns true if `setNfcOperate` has been explicitly set.
  var hasSetNfcOperate: Bool {return _storage._setNfcOperate != nil}
  /// Clears the value of `setNfcOperate`. Subsequent reads from it will return its default value.
  mutating func clearSetNfcOperate() {_uniqueStorage()._setNfcOperate = nil}

  var setPageSwitch: set_page_switch_t {
    get {return _storage._setPageSwitch ?? set_page_switch_t()}
    set {_uniqueStorage()._setPageSwitch = newValue}
  }
  /// Returns true if `setPageSwitch` has been explicitly set.
  var hasSetPageSwitch: Bool {return _storage._setPageSwitch != nil}
  /// Clears the value of `setPageSwitch`. Subsequent reads from it will return its default value.
  mutating func clearSetPageSwitch() {_uniqueStorage()._setPageSwitch = nil}

  var setCheckGpsInfo: set_check_gps_info_t {
    get {return _storage._setCheckGpsInfo ?? set_check_gps_info_t()}
    set {_uniqueStorage()._setCheckGpsInfo = newValue}
  }
  /// Returns true if `setCheckGpsInfo` has been explicitly set.
  var hasSetCheckGpsInfo: Bool {return _storage._setCheckGpsInfo != nil}
  /// Clears the value of `setCheckGpsInfo`. Subsequent reads from it will return its default value.
  mutating func clearSetCheckGpsInfo() {_uniqueStorage()._setCheckGpsInfo = nil}

  var setUpdateGpsData: set_update_gps_data_t {
    get {return _storage._setUpdateGpsData ?? set_update_gps_data_t()}
    set {_uniqueStorage()._setUpdateGpsData = newValue}
  }
  /// Returns true if `setUpdateGpsData` has been explicitly set.
  var hasSetUpdateGpsData: Bool {return _storage._setUpdateGpsData != nil}
  /// Clears the value of `setUpdateGpsData`. Subsequent reads from it will return its default value.
  mutating func clearSetUpdateGpsData() {_uniqueStorage()._setUpdateGpsData = nil}

  var setUpdateSpo2Data: set_update_spo2_data_t {
    get {return _storage._setUpdateSpo2Data ?? set_update_spo2_data_t()}
    set {_uniqueStorage()._setUpdateSpo2Data = newValue}
  }
  /// Returns true if `setUpdateSpo2Data` has been explicitly set.
  var hasSetUpdateSpo2Data: Bool {return _storage._setUpdateSpo2Data != nil}
  /// Clears the value of `setUpdateSpo2Data`. Subsequent reads from it will return its default value.
  mutating func clearSetUpdateSpo2Data() {_uniqueStorage()._setUpdateSpo2Data = nil}

  var getDialConfigData: get_dial_config_data_t {
    get {return _storage._getDialConfigData ?? get_dial_config_data_t()}
    set {_uniqueStorage()._getDialConfigData = newValue}
  }
  /// Returns true if `getDialConfigData` has been explicitly set.
  var hasGetDialConfigData: Bool {return _storage._getDialConfigData != nil}
  /// Clears the value of `getDialConfigData`. Subsequent reads from it will return its default value.
  mutating func clearGetDialConfigData() {_uniqueStorage()._getDialConfigData = nil}

  var setWarmingData: set_warming_data_t {
    get {return _storage._setWarmingData ?? set_warming_data_t()}
    set {_uniqueStorage()._setWarmingData = newValue}
  }
  /// Returns true if `setWarmingData` has been explicitly set.
  var hasSetWarmingData: Bool {return _storage._setWarmingData != nil}
  /// Clears the value of `setWarmingData`. Subsequent reads from it will return its default value.
  mutating func clearSetWarmingData() {_uniqueStorage()._setWarmingData = nil}

  var setMenuSeqData: set_menu_sequence_t {
    get {return _storage._setMenuSeqData ?? set_menu_sequence_t()}
    set {_uniqueStorage()._setMenuSeqData = newValue}
  }
  /// Returns true if `setMenuSeqData` has been explicitly set.
  var hasSetMenuSeqData: Bool {return _storage._setMenuSeqData != nil}
  /// Clears the value of `setMenuSeqData`. Subsequent reads from it will return its default value.
  mutating func clearSetMenuSeqData() {_uniqueStorage()._setMenuSeqData = nil}

  var getMenuSeqData: get_menu_sequence_t {
    get {return _storage._getMenuSeqData ?? get_menu_sequence_t()}
    set {_uniqueStorage()._getMenuSeqData = newValue}
  }
  /// Returns true if `getMenuSeqData` has been explicitly set.
  var hasGetMenuSeqData: Bool {return _storage._getMenuSeqData != nil}
  /// Clears the value of `getMenuSeqData`. Subsequent reads from it will return its default value.
  mutating func clearGetMenuSeqData() {_uniqueStorage()._getMenuSeqData = nil}

  var rGetMenuSeqData: r_get_menu_sequence_t {
    get {return _storage._rGetMenuSeqData ?? r_get_menu_sequence_t()}
    set {_uniqueStorage()._rGetMenuSeqData = newValue}
  }
  /// Returns true if `rGetMenuSeqData` has been explicitly set.
  var hasRGetMenuSeqData: Bool {return _storage._rGetMenuSeqData != nil}
  /// Clears the value of `rGetMenuSeqData`. Subsequent reads from it will return its default value.
  mutating func clearRGetMenuSeqData() {_uniqueStorage()._rGetMenuSeqData = nil}

  var getNfcCardData: get_nfc_card_data_t {
    get {return _storage._getNfcCardData ?? get_nfc_card_data_t()}
    set {_uniqueStorage()._getNfcCardData = newValue}
  }
  /// Returns true if `getNfcCardData` has been explicitly set.
  var hasGetNfcCardData: Bool {return _storage._getNfcCardData != nil}
  /// Clears the value of `getNfcCardData`. Subsequent reads from it will return its default value.
  mutating func clearGetNfcCardData() {_uniqueStorage()._getNfcCardData = nil}

  var setSpo2Detect: set_spo2_detect_t {
    get {return _storage._setSpo2Detect ?? set_spo2_detect_t()}
    set {_uniqueStorage()._setSpo2Detect = newValue}
  }
  /// Returns true if `setSpo2Detect` has been explicitly set.
  var hasSetSpo2Detect: Bool {return _storage._setSpo2Detect != nil}
  /// Clears the value of `setSpo2Detect`. Subsequent reads from it will return its default value.
  mutating func clearSetSpo2Detect() {_uniqueStorage()._setSpo2Detect = nil}

  var rGetSpo2Detect: r_get_spo2_detect_t {
    get {return _storage._rGetSpo2Detect ?? r_get_spo2_detect_t()}
    set {_uniqueStorage()._rGetSpo2Detect = newValue}
  }
  /// Returns true if `rGetSpo2Detect` has been explicitly set.
  var hasRGetSpo2Detect: Bool {return _storage._rGetSpo2Detect != nil}
  /// Clears the value of `rGetSpo2Detect`. Subsequent reads from it will return its default value.
  mutating func clearRGetSpo2Detect() {_uniqueStorage()._rGetSpo2Detect = nil}

  var swsnInfo: swsn_info_t {
    get {return _storage._swsnInfo ?? swsn_info_t()}
    set {_uniqueStorage()._swsnInfo = newValue}
  }
  /// Returns true if `swsnInfo` has been explicitly set.
  var hasSwsnInfo: Bool {return _storage._swsnInfo != nil}
  /// Clears the value of `swsnInfo`. Subsequent reads from it will return its default value.
  mutating func clearSwsnInfo() {_uniqueStorage()._swsnInfo = nil}

  var setPhoneAppStatus: set_phone_app_status_t {
    get {return _storage._setPhoneAppStatus ?? set_phone_app_status_t()}
    set {_uniqueStorage()._setPhoneAppStatus = newValue}
  }
  /// Returns true if `setPhoneAppStatus` has been explicitly set.
  var hasSetPhoneAppStatus: Bool {return _storage._setPhoneAppStatus != nil}
  /// Clears the value of `setPhoneAppStatus`. Subsequent reads from it will return its default value.
  mutating func clearSetPhoneAppStatus() {_uniqueStorage()._setPhoneAppStatus = nil}

  var setFemaleHealthInfo: set_female_health_info_t {
    get {return _storage._setFemaleHealthInfo ?? set_female_health_info_t()}
    set {_uniqueStorage()._setFemaleHealthInfo = newValue}
  }
  /// Returns true if `setFemaleHealthInfo` has been explicitly set.
  var hasSetFemaleHealthInfo: Bool {return _storage._setFemaleHealthInfo != nil}
  /// Clears the value of `setFemaleHealthInfo`. Subsequent reads from it will return its default value.
  mutating func clearSetFemaleHealthInfo() {_uniqueStorage()._setFemaleHealthInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

  enum cmd_t: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case cmdBindDevice // = 1
    case cmdGetDeviceInfo // = 2
    case cmdSyncPhoneInfo // = 3
    case cmdSyncUserInfo // = 4
    case cmdSyncSwitch // = 5
    case cmdSetHrSampleSlot // = 6
    case cmdSetLongsitDuration // = 7
    case cmdSetDrinkSlot // = 8
    case cmdSetAlarms // = 9
    case cmdSetNotdisturb // = 10
    case cmdSetCountryInfo // = 11
    case cmdSetUiStyle // = 12
    case cmdSetSportTarget // = 13
    case cmdSetTimeFormat // = 14
    case cmdSetMetricInch // = 15
    case cmdSetBrightTimes // = 16
    case cmdSetHrWarning // = 17
    case cmdGetHrValue // = 18
    case cmdSetNotifyWarn // = 19
    case cmdSetSyncHealthData // = 20
    case cmdGetPowerValue // = 21
    case cmdSetUpdataFw // = 22
    case cmdSetTakePic // = 23
    case cmdSetFindPhone // = 24
    case cmdSetFindDev // = 25
    case cmdSetWeatherInfo // = 26
    case cmdSetResetMachine // = 27
    case cmdSetSportStatus // = 28
    case cmdGetHealthData // = 29
    case cmdSetMusicInfo // = 30
    case cmdGetSyncMtu // = 31
    case cmdSetBinDataUpdate // = 32
    case cmdFactoryTestMode // = 33
    case cmdSendBigData // = 34
    case cmdGetRealtimeHr // = 35
    case cmdSyncRealtimeHr // = 36
    case cmdHandUpPhone // = 37
    case cmdDisturbSwitch // = 38
    case cmdCtrAppSports // = 39
    case cmdSyncStepCount // = 40
    case cmdCheckSportStatus // = 41
    case cmdGetCurrentSportHr // = 42
    case cmdSetMakeTestData // = 43
    case cmdSetLightLeakResult // = 44
    case cmdGetActiveRecordData // = 45
    case cmdSetActiveRecordData // = 46
    case cmdSetLogInfoData // = 47
    case cmdGetLogInfoData // = 48
    case cmdGetUiHrsValue // = 49
    case cmdSetAllConfigParam // = 50
    case cmdSetNfcOperateCode // = 51
    case cmdSetPageSwitch // = 52
    case cmdSetCheckGpsInfo // = 53
    case cmdSetUpdateGpsData // = 54
    case cmdGetUpdateSpo2Data // = 55
    case cmdGetDialConfigData // = 56
    case cmdSetWarmingData // = 57
    case cmdGetMenuSequenceData // = 58
    case cmdSetMenuSequenceData // = 59
    case cmdNfcAccessCardData // = 60
    case cmdSetSpo2Detect // = 61
    case cmdGetSpo2Detect // = 62
    case cmdSwsnGetDataInfo // = 63
    case cmdSwsnSetDataInfo // = 64
    case cmdPhoneAppSetStatus // = 65
    case cmdGetAlarms // = 66
    case cmdSetFemaleHealthInfo // = 67

    init() {
      self = .cmdBindDevice
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .cmdBindDevice
      case 2: self = .cmdGetDeviceInfo
      case 3: self = .cmdSyncPhoneInfo
      case 4: self = .cmdSyncUserInfo
      case 5: self = .cmdSyncSwitch
      case 6: self = .cmdSetHrSampleSlot
      case 7: self = .cmdSetLongsitDuration
      case 8: self = .cmdSetDrinkSlot
      case 9: self = .cmdSetAlarms
      case 10: self = .cmdSetNotdisturb
      case 11: self = .cmdSetCountryInfo
      case 12: self = .cmdSetUiStyle
      case 13: self = .cmdSetSportTarget
      case 14: self = .cmdSetTimeFormat
      case 15: self = .cmdSetMetricInch
      case 16: self = .cmdSetBrightTimes
      case 17: self = .cmdSetHrWarning
      case 18: self = .cmdGetHrValue
      case 19: self = .cmdSetNotifyWarn
      case 20: self = .cmdSetSyncHealthData
      case 21: self = .cmdGetPowerValue
      case 22: self = .cmdSetUpdataFw
      case 23: self = .cmdSetTakePic
      case 24: self = .cmdSetFindPhone
      case 25: self = .cmdSetFindDev
      case 26: self = .cmdSetWeatherInfo
      case 27: self = .cmdSetResetMachine
      case 28: self = .cmdSetSportStatus
      case 29: self = .cmdGetHealthData
      case 30: self = .cmdSetMusicInfo
      case 31: self = .cmdGetSyncMtu
      case 32: self = .cmdSetBinDataUpdate
      case 33: self = .cmdFactoryTestMode
      case 34: self = .cmdSendBigData
      case 35: self = .cmdGetRealtimeHr
      case 36: self = .cmdSyncRealtimeHr
      case 37: self = .cmdHandUpPhone
      case 38: self = .cmdDisturbSwitch
      case 39: self = .cmdCtrAppSports
      case 40: self = .cmdSyncStepCount
      case 41: self = .cmdCheckSportStatus
      case 42: self = .cmdGetCurrentSportHr
      case 43: self = .cmdSetMakeTestData
      case 44: self = .cmdSetLightLeakResult
      case 45: self = .cmdGetActiveRecordData
      case 46: self = .cmdSetActiveRecordData
      case 47: self = .cmdSetLogInfoData
      case 48: self = .cmdGetLogInfoData
      case 49: self = .cmdGetUiHrsValue
      case 50: self = .cmdSetAllConfigParam
      case 51: self = .cmdSetNfcOperateCode
      case 52: self = .cmdSetPageSwitch
      case 53: self = .cmdSetCheckGpsInfo
      case 54: self = .cmdSetUpdateGpsData
      case 55: self = .cmdGetUpdateSpo2Data
      case 56: self = .cmdGetDialConfigData
      case 57: self = .cmdSetWarmingData
      case 58: self = .cmdGetMenuSequenceData
      case 59: self = .cmdSetMenuSequenceData
      case 60: self = .cmdNfcAccessCardData
      case 61: self = .cmdSetSpo2Detect
      case 62: self = .cmdGetSpo2Detect
      case 63: self = .cmdSwsnGetDataInfo
      case 64: self = .cmdSwsnSetDataInfo
      case 65: self = .cmdPhoneAppSetStatus
      case 66: self = .cmdGetAlarms
      case 67: self = .cmdSetFemaleHealthInfo
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .cmdBindDevice: return 1
      case .cmdGetDeviceInfo: return 2
      case .cmdSyncPhoneInfo: return 3
      case .cmdSyncUserInfo: return 4
      case .cmdSyncSwitch: return 5
      case .cmdSetHrSampleSlot: return 6
      case .cmdSetLongsitDuration: return 7
      case .cmdSetDrinkSlot: return 8
      case .cmdSetAlarms: return 9
      case .cmdSetNotdisturb: return 10
      case .cmdSetCountryInfo: return 11
      case .cmdSetUiStyle: return 12
      case .cmdSetSportTarget: return 13
      case .cmdSetTimeFormat: return 14
      case .cmdSetMetricInch: return 15
      case .cmdSetBrightTimes: return 16
      case .cmdSetHrWarning: return 17
      case .cmdGetHrValue: return 18
      case .cmdSetNotifyWarn: return 19
      case .cmdSetSyncHealthData: return 20
      case .cmdGetPowerValue: return 21
      case .cmdSetUpdataFw: return 22
      case .cmdSetTakePic: return 23
      case .cmdSetFindPhone: return 24
      case .cmdSetFindDev: return 25
      case .cmdSetWeatherInfo: return 26
      case .cmdSetResetMachine: return 27
      case .cmdSetSportStatus: return 28
      case .cmdGetHealthData: return 29
      case .cmdSetMusicInfo: return 30
      case .cmdGetSyncMtu: return 31
      case .cmdSetBinDataUpdate: return 32
      case .cmdFactoryTestMode: return 33
      case .cmdSendBigData: return 34
      case .cmdGetRealtimeHr: return 35
      case .cmdSyncRealtimeHr: return 36
      case .cmdHandUpPhone: return 37
      case .cmdDisturbSwitch: return 38
      case .cmdCtrAppSports: return 39
      case .cmdSyncStepCount: return 40
      case .cmdCheckSportStatus: return 41
      case .cmdGetCurrentSportHr: return 42
      case .cmdSetMakeTestData: return 43
      case .cmdSetLightLeakResult: return 44
      case .cmdGetActiveRecordData: return 45
      case .cmdSetActiveRecordData: return 46
      case .cmdSetLogInfoData: return 47
      case .cmdGetLogInfoData: return 48
      case .cmdGetUiHrsValue: return 49
      case .cmdSetAllConfigParam: return 50
      case .cmdSetNfcOperateCode: return 51
      case .cmdSetPageSwitch: return 52
      case .cmdSetCheckGpsInfo: return 53
      case .cmdSetUpdateGpsData: return 54
      case .cmdGetUpdateSpo2Data: return 55
      case .cmdGetDialConfigData: return 56
      case .cmdSetWarmingData: return 57
      case .cmdGetMenuSequenceData: return 58
      case .cmdSetMenuSequenceData: return 59
      case .cmdNfcAccessCardData: return 60
      case .cmdSetSpo2Detect: return 61
      case .cmdGetSpo2Detect: return 62
      case .cmdSwsnGetDataInfo: return 63
      case .cmdSwsnSetDataInfo: return 64
      case .cmdPhoneAppSetStatus: return 65
      case .cmdGetAlarms: return 66
      case .cmdSetFemaleHealthInfo: return 67
      }
    }

  }

    public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension hl_cmds.cmd_t: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ver_t: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PB_VERSION"),
  ]
}

extension weather_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "weather_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_weather_num"),
    2: .standard(proto: "m_climate"),
    3: .standard(proto: "m_temperature"),
    4: .standard(proto: "m_pm25"),
    5: .standard(proto: "m_aqi"),
    6: .standard(proto: "m_city"),
    7: .standard(proto: "m_max_temp"),
    8: .standard(proto: "m_min_temp"),
    9: .standard(proto: "m_seconds"),
  ]

  public var isInitialized: Bool {
    if self._mWeatherNum == nil {return false}
    if self._mClimate == nil {return false}
    if self._mTemperature == nil {return false}
    if self._mPm25 == nil {return false}
    if self._mAqi == nil {return false}
    if self._mCity == nil {return false}
    if self._mMaxTemp == nil {return false}
    if self._mMinTemp == nil {return false}
    if self._mSeconds == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mWeatherNum) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mClimate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mTemperature) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mPm25) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mAqi) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mCity) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._mMaxTemp) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._mMinTemp) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._mSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mWeatherNum {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mClimate {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mTemperature {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mPm25 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mAqi {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mCity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._mMaxTemp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._mMinTemp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._mSeconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: weather_t, rhs: weather_t) -> Bool {
    if lhs._mWeatherNum != rhs._mWeatherNum {return false}
    if lhs._mClimate != rhs._mClimate {return false}
    if lhs._mTemperature != rhs._mTemperature {return false}
    if lhs._mPm25 != rhs._mPm25 {return false}
    if lhs._mAqi != rhs._mAqi {return false}
    if lhs._mCity != rhs._mCity {return false}
    if lhs._mMaxTemp != rhs._mMaxTemp {return false}
    if lhs._mMinTemp != rhs._mMinTemp {return false}
    if lhs._mSeconds != rhs._mSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alarm_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "alarm_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_alarm1_cfg"),
    2: .standard(proto: "m_alarm1_hour"),
    3: .standard(proto: "m_alarm1_min"),
    4: .standard(proto: "m_alarm1_once"),
    5: .standard(proto: "m_alarm1_remarks"),
  ]

  public var isInitialized: Bool {
    if self._mAlarm1Cfg == nil {return false}
    if self._mAlarm1Hour == nil {return false}
    if self._mAlarm1Min == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._mAlarm1Cfg) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mAlarm1Hour) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mAlarm1Min) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mAlarm1Once) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._mAlarm1Remarks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mAlarm1Cfg {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._mAlarm1Hour {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mAlarm1Min {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mAlarm1Once {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mAlarm1Remarks {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: alarm_t, rhs: alarm_t) -> Bool {
    if lhs._mAlarm1Cfg != rhs._mAlarm1Cfg {return false}
    if lhs._mAlarm1Hour != rhs._mAlarm1Hour {return false}
    if lhs._mAlarm1Min != rhs._mAlarm1Min {return false}
    if lhs._mAlarm1Once != rhs._mAlarm1Once {return false}
    if lhs._mAlarm1Remarks != rhs._mAlarm1Remarks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension bind_app_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "bind_app_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_usrid"),
    2: .standard(proto: "m_gender"),
    3: .standard(proto: "m_age"),
    4: .standard(proto: "m_height"),
    5: .standard(proto: "m_weight"),
    6: .standard(proto: "m_wearstyle"),
  ]

  public var isInitialized: Bool {
    if self._mUsrid == nil {return false}
    if self._mGender == nil {return false}
    if self._mAge == nil {return false}
    if self._mHeight == nil {return false}
    if self._mWeight == nil {return false}
    if self._mWearstyle == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mUsrid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mGender) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mAge) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mHeight) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mWeight) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mWearstyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mUsrid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mGender {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mAge {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mHeight {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mWeight {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mWearstyle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: bind_app_info_t, rhs: bind_app_info_t) -> Bool {
    if lhs._mUsrid != rhs._mUsrid {return false}
    if lhs._mGender != rhs._mGender {return false}
    if lhs._mAge != rhs._mAge {return false}
    if lhs._mHeight != rhs._mHeight {return false}
    if lhs._mWeight != rhs._mWeight {return false}
    if lhs._mWearstyle != rhs._mWearstyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_bind_device_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_bind_device_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_projno"),
    2: .standard(proto: "m_hwversion"),
    3: .standard(proto: "m_fwversion"),
    4: .standard(proto: "m_fontversion"),
    5: .standard(proto: "m_sdversion"),
    6: .standard(proto: "m_uiversion"),
    7: .standard(proto: "m_devicesn"),
    8: .standard(proto: "m_devicename"),
    9: .standard(proto: "m_battvalue"),
    10: .standard(proto: "m_devicemac"),
    11: .standard(proto: "m_bind_operate"),
    12: .standard(proto: "m_power"),
    13: .standard(proto: "m_langversion"),
  ]

  public var isInitialized: Bool {
    if self._mProjno == nil {return false}
    if self._mHwversion == nil {return false}
    if self._mFwversion == nil {return false}
    if self._mFontversion == nil {return false}
    if self._mSdversion == nil {return false}
    if self._mUiversion == nil {return false}
    if self._mDevicesn == nil {return false}
    if self._mDevicename == nil {return false}
    if self._mBattvalue == nil {return false}
    if self._mDevicemac == nil {return false}
    if self._mBindOperate == nil {return false}
    if self._mPower == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._mProjno) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mHwversion) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mFwversion) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mFontversion) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mSdversion) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mUiversion) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._mDevicesn) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._mDevicename) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._mBattvalue) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._mDevicemac) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._mBindOperate) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self._mPower) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self._mLangversion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mProjno {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._mHwversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mFwversion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._mFontversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mSdversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mUiversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._mDevicesn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._mDevicename {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._mBattvalue {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._mDevicemac {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._mBindOperate {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    }
    if let v = self._mPower {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    }
    if let v = self._mLangversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_bind_device_t, rhs: r_bind_device_t) -> Bool {
    if lhs._mProjno != rhs._mProjno {return false}
    if lhs._mHwversion != rhs._mHwversion {return false}
    if lhs._mFwversion != rhs._mFwversion {return false}
    if lhs._mFontversion != rhs._mFontversion {return false}
    if lhs._mSdversion != rhs._mSdversion {return false}
    if lhs._mUiversion != rhs._mUiversion {return false}
    if lhs._mDevicesn != rhs._mDevicesn {return false}
    if lhs._mDevicename != rhs._mDevicename {return false}
    if lhs._mBattvalue != rhs._mBattvalue {return false}
    if lhs._mDevicemac != rhs._mDevicemac {return false}
    if lhs._mBindOperate != rhs._mBindOperate {return false}
    if lhs._mPower != rhs._mPower {return false}
    if lhs._mLangversion != rhs._mLangversion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_device_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_device_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_projno"),
    2: .standard(proto: "m_hwversion"),
    3: .standard(proto: "m_fwversion"),
    4: .standard(proto: "m_fontversion"),
    5: .standard(proto: "m_sdversion"),
    6: .standard(proto: "m_uiversion"),
    7: .standard(proto: "m_devicesn"),
    8: .standard(proto: "m_devicename"),
    9: .standard(proto: "m_battvalue"),
    10: .standard(proto: "m_devicemac"),
    11: .standard(proto: "m_langversion"),
  ]

  public var isInitialized: Bool {
    if self._mProjno == nil {return false}
    if self._mHwversion == nil {return false}
    if self._mFwversion == nil {return false}
    if self._mFontversion == nil {return false}
    if self._mSdversion == nil {return false}
    if self._mUiversion == nil {return false}
    if self._mDevicesn == nil {return false}
    if self._mDevicename == nil {return false}
    if self._mBattvalue == nil {return false}
    if self._mDevicemac == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._mProjno) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mHwversion) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mFwversion) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mFontversion) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mSdversion) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mUiversion) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._mDevicesn) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._mDevicename) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._mBattvalue) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._mDevicemac) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._mLangversion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mProjno {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._mHwversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mFwversion {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._mFontversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mSdversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mUiversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._mDevicesn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._mDevicename {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._mBattvalue {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._mDevicemac {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._mLangversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_device_info_t, rhs: r_get_device_info_t) -> Bool {
    if lhs._mProjno != rhs._mProjno {return false}
    if lhs._mHwversion != rhs._mHwversion {return false}
    if lhs._mFwversion != rhs._mFwversion {return false}
    if lhs._mFontversion != rhs._mFontversion {return false}
    if lhs._mSdversion != rhs._mSdversion {return false}
    if lhs._mUiversion != rhs._mUiversion {return false}
    if lhs._mDevicesn != rhs._mDevicesn {return false}
    if lhs._mDevicename != rhs._mDevicename {return false}
    if lhs._mBattvalue != rhs._mBattvalue {return false}
    if lhs._mDevicemac != rhs._mDevicemac {return false}
    if lhs._mLangversion != rhs._mLangversion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension sync_phone_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "sync_phone_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_phonemodel"),
    2: .standard(proto: "m_systemversion"),
    3: .standard(proto: "m_appversion"),
    4: .standard(proto: "m_language"),
  ]

  public var isInitialized: Bool {
    if self._mPhonemodel == nil {return false}
    if self._mSystemversion == nil {return false}
    if self._mAppversion == nil {return false}
    if self._mLanguage == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mPhonemodel) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mSystemversion) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mAppversion) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mLanguage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mPhonemodel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mSystemversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mAppversion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mLanguage {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: sync_phone_info_t, rhs: sync_phone_info_t) -> Bool {
    if lhs._mPhonemodel != rhs._mPhonemodel {return false}
    if lhs._mSystemversion != rhs._mSystemversion {return false}
    if lhs._mAppversion != rhs._mAppversion {return false}
    if lhs._mLanguage != rhs._mLanguage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension sync_user_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "sync_user_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_usrid"),
    2: .standard(proto: "m_gender"),
    3: .standard(proto: "m_age"),
    4: .standard(proto: "m_height"),
    5: .standard(proto: "m_weight"),
    6: .standard(proto: "m_wearstyle"),
  ]

  public var isInitialized: Bool {
    if self._mUsrid == nil {return false}
    if self._mGender == nil {return false}
    if self._mAge == nil {return false}
    if self._mHeight == nil {return false}
    if self._mWeight == nil {return false}
    if self._mWearstyle == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mUsrid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mGender) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mAge) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mHeight) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mWeight) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mWearstyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mUsrid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mGender {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mAge {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mHeight {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mWeight {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mWearstyle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: sync_user_info_t, rhs: sync_user_info_t) -> Bool {
    if lhs._mUsrid != rhs._mUsrid {return false}
    if lhs._mGender != rhs._mGender {return false}
    if lhs._mAge != rhs._mAge {return false}
    if lhs._mHeight != rhs._mHeight {return false}
    if lhs._mWeight != rhs._mWeight {return false}
    if lhs._mWearstyle != rhs._mWearstyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_drink_slot_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_drink_slot_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_drink_slot"),
    2: .standard(proto: "m_start_time"),
    3: .standard(proto: "m_end_time"),
    4: .standard(proto: "m_nodisturb_start_time"),
    5: .standard(proto: "m_nodisturb_end_time"),
  ]

  public var isInitialized: Bool {
    if self._mDrinkSlot == nil {return false}
    if self._mStartTime == nil {return false}
    if self._mEndTime == nil {return false}
    if self._mNodisturbStartTime == nil {return false}
    if self._mNodisturbEndTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mDrinkSlot) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mStartTime) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mEndTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mNodisturbStartTime) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mNodisturbEndTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mDrinkSlot {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mStartTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mEndTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mNodisturbStartTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mNodisturbEndTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_drink_slot_t, rhs: set_drink_slot_t) -> Bool {
    if lhs._mDrinkSlot != rhs._mDrinkSlot {return false}
    if lhs._mStartTime != rhs._mStartTime {return false}
    if lhs._mEndTime != rhs._mEndTime {return false}
    if lhs._mNodisturbStartTime != rhs._mNodisturbStartTime {return false}
    if lhs._mNodisturbEndTime != rhs._mNodisturbEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension sync_switch_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "sync_switch_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_switchs"),
  ]

  public var isInitialized: Bool {
    if self._mSwitchs == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._mSwitchs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mSwitchs {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: sync_switch_t, rhs: sync_switch_t) -> Bool {
    if lhs._mSwitchs != rhs._mSwitchs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_hr_sample_slot_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_hr_sample_slot_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_hr_slot"),
  ]

  public var isInitialized: Bool {
    if self._mHrSlot == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mHrSlot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mHrSlot {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_hr_sample_slot_t, rhs: set_hr_sample_slot_t) -> Bool {
    if lhs._mHrSlot != rhs._mHrSlot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_longsit_duration_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_longsit_duration_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_longsit_duration"),
    2: .standard(proto: "m_start_time"),
    3: .standard(proto: "m_end_time"),
    4: .standard(proto: "m_nodisturb_start_time"),
    5: .standard(proto: "m_nodisturb_end_time"),
  ]

  public var isInitialized: Bool {
    if self._mLongsitDuration == nil {return false}
    if self._mStartTime == nil {return false}
    if self._mEndTime == nil {return false}
    if self._mNodisturbStartTime == nil {return false}
    if self._mNodisturbEndTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mLongsitDuration) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mStartTime) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mEndTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mNodisturbStartTime) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mNodisturbEndTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mLongsitDuration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mStartTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mEndTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mNodisturbStartTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mNodisturbEndTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_longsit_duration_t, rhs: set_longsit_duration_t) -> Bool {
    if lhs._mLongsitDuration != rhs._mLongsitDuration {return false}
    if lhs._mStartTime != rhs._mStartTime {return false}
    if lhs._mEndTime != rhs._mEndTime {return false}
    if lhs._mNodisturbStartTime != rhs._mNodisturbStartTime {return false}
    if lhs._mNodisturbEndTime != rhs._mNodisturbEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_notdisturb_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_notdisturb_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_notdisturb_time_1"),
    2: .standard(proto: "m_notdisturb_time_2"),
  ]

  public var isInitialized: Bool {
    if self._mNotdisturbTime1 == nil {return false}
    if self._mNotdisturbTime2 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._mNotdisturbTime1) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._mNotdisturbTime2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mNotdisturbTime1 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._mNotdisturbTime2 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_notdisturb_t, rhs: set_notdisturb_t) -> Bool {
    if lhs._mNotdisturbTime1 != rhs._mNotdisturbTime1 {return false}
    if lhs._mNotdisturbTime2 != rhs._mNotdisturbTime2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_country_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_country_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_country_name"),
    2: .standard(proto: "m_country_timezone"),
  ]

  public var isInitialized: Bool {
    if self._mCountryName == nil {return false}
    if self._mCountryTimezone == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._mCountryName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mCountryTimezone) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mCountryName {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._mCountryTimezone {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_country_info_t, rhs: set_country_info_t) -> Bool {
    if lhs._mCountryName != rhs._mCountryName {return false}
    if lhs._mCountryTimezone != rhs._mCountryTimezone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_ui_style_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_ui_style_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_ui_style"),
    2: .standard(proto: "m_dial_clock"),
  ]

  public var isInitialized: Bool {
    if self._mUiStyle == nil {return false}
    if self._mDialClock == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mUiStyle) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mDialClock) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mUiStyle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mDialClock {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_ui_style_t, rhs: set_ui_style_t) -> Bool {
    if lhs._mUiStyle != rhs._mUiStyle {return false}
    if lhs._mDialClock != rhs._mDialClock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_sport_target_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_sport_target_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_target_cal"),
    2: .standard(proto: "m_target_dis"),
    3: .standard(proto: "m_target_step"),
    4: .standard(proto: "m_target_actime"),
    5: .standard(proto: "m_check"),
  ]

  public var isInitialized: Bool {
    if self._mTargetCal == nil {return false}
    if self._mTargetDis == nil {return false}
    if self._mTargetStep == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mTargetCal) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mTargetDis) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mTargetStep) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mTargetActime) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mCheck) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mTargetCal {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mTargetDis {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mTargetStep {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mTargetActime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mCheck {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_sport_target_t, rhs: set_sport_target_t) -> Bool {
    if lhs._mTargetCal != rhs._mTargetCal {return false}
    if lhs._mTargetDis != rhs._mTargetDis {return false}
    if lhs._mTargetStep != rhs._mTargetStep {return false}
    if lhs._mTargetActime != rhs._mTargetActime {return false}
    if lhs._mCheck != rhs._mCheck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_time_format_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_time_format_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_time_format"),
  ]

  public var isInitialized: Bool {
    if self._mTimeFormat == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mTimeFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mTimeFormat {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_time_format_t, rhs: set_time_format_t) -> Bool {
    if lhs._mTimeFormat != rhs._mTimeFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_metric_inch_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_metric_inch_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_metric_inch"),
  ]

  public var isInitialized: Bool {
    if self._mMetricInch == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mMetricInch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mMetricInch {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_metric_inch_t, rhs: set_metric_inch_t) -> Bool {
    if lhs._mMetricInch != rhs._mMetricInch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_bright_times_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_bright_times_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_bright_time"),
  ]

  public var isInitialized: Bool {
    if self._mBrightTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mBrightTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mBrightTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_bright_times_t, rhs: set_bright_times_t) -> Bool {
    if lhs._mBrightTime != rhs._mBrightTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_hr_warning_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_hr_warning_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_hr_upper"),
    2: .standard(proto: "m_hr_lower"),
  ]

  public var isInitialized: Bool {
    if self._mHrUpper == nil {return false}
    if self._mHrLower == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mHrUpper) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mHrLower) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mHrUpper {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mHrLower {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_hr_warning_t, rhs: set_hr_warning_t) -> Bool {
    if lhs._mHrUpper != rhs._mHrUpper {return false}
    if lhs._mHrLower != rhs._mHrLower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_hr_value_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_hr_value_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_hr_value"),
    2: .standard(proto: "m_err_code"),
  ]

  public var isInitialized: Bool {
    if self._mHrValue == nil {return false}
    if self._mErrCode == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mHrValue) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mErrCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mHrValue {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mErrCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_hr_value_t, rhs: r_get_hr_value_t) -> Bool {
    if lhs._mHrValue != rhs._mHrValue {return false}
    if lhs._mErrCode != rhs._mErrCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_notify_warning_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_notify_warning_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_notify_type"),
    2: .standard(proto: "m_title_len"),
    3: .standard(proto: "m_msg_len"),
    4: .standard(proto: "m_reserved"),
    5: .standard(proto: "m_title"),
    6: .standard(proto: "m_msg"),
    7: .standard(proto: "m_utc"),
  ]

  public var isInitialized: Bool {
    if self._mNotifyType == nil {return false}
    if self._mTitleLen == nil {return false}
    if self._mMsgLen == nil {return false}
    if self._mReserved == nil {return false}
    if self._mTitle == nil {return false}
    if self._mMsg == nil {return false}
    if self._mUtc == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mNotifyType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mTitleLen) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mMsgLen) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._mReserved) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._mTitle) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._mMsg) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._mUtc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mNotifyType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mTitleLen {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mMsgLen {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mReserved {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._mTitle {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    if let v = self._mMsg {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }
    if let v = self._mUtc {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_notify_warning_t, rhs: set_notify_warning_t) -> Bool {
    if lhs._mNotifyType != rhs._mNotifyType {return false}
    if lhs._mTitleLen != rhs._mTitleLen {return false}
    if lhs._mMsgLen != rhs._mMsgLen {return false}
    if lhs._mReserved != rhs._mReserved {return false}
    if lhs._mTitle != rhs._mTitle {return false}
    if lhs._mMsg != rhs._mMsg {return false}
    if lhs._mUtc != rhs._mUtc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_sync_health_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_sync_health_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_sync_type"),
    2: .standard(proto: "m_second_start"),
    3: .standard(proto: "m_second_end"),
  ]

  public var isInitialized: Bool {
    if self._mSyncType == nil {return false}
    if self._mSecondStart == nil {return false}
    if self._mSecondEnd == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mSyncType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mSecondStart) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mSecondEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mSyncType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mSecondStart {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mSecondEnd {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_sync_health_data_t, rhs: r_sync_health_data_t) -> Bool {
    if lhs._mSyncType != rhs._mSyncType {return false}
    if lhs._mSecondStart != rhs._mSecondStart {return false}
    if lhs._mSecondEnd != rhs._mSecondEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_health_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_health_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_err_code"),
    2: .standard(proto: "m_sn"),
    3: .standard(proto: "m_data"),
  ]

  public var isInitialized: Bool {
    if self._mErrCode == nil {return false}
    if self._mSn == nil {return false}
    if self._mData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mErrCode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mSn) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mErrCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mSn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_health_data_t, rhs: r_get_health_data_t) -> Bool {
    if lhs._mErrCode != rhs._mErrCode {return false}
    if lhs._mSn != rhs._mSn {return false}
    if lhs._mData != rhs._mData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_power_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_power_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_err_code"),
    2: .standard(proto: "m_power"),
  ]

  public var isInitialized: Bool {
    if self._mErrCode == nil {return false}
    if self._mPower == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mErrCode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mPower) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mErrCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mPower {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_power_t, rhs: r_get_power_t) -> Bool {
    if lhs._mErrCode != rhs._mErrCode {return false}
    if lhs._mPower != rhs._mPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_updata_fw_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_updata_fw_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_new_version"),
  ]

  public var isInitialized: Bool {
    if self._mNewVersion == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mNewVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mNewVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_updata_fw_t, rhs: set_updata_fw_t) -> Bool {
    if lhs._mNewVersion != rhs._mNewVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_weather_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_weather_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weathers"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.weathers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.weathers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weathers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weathers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_weather_info_t, rhs: set_weather_info_t) -> Bool {
    if lhs.weathers != rhs.weathers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_reset_machine_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_reset_machine_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_factory_mode"),
  ]

  public var isInitialized: Bool {
    if self._mFactoryMode == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mFactoryMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mFactoryMode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_reset_machine_t, rhs: set_reset_machine_t) -> Bool {
    if lhs._mFactoryMode != rhs._mFactoryMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_sport_status_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_sport_status_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_sport_mode"),
    2: .standard(proto: "m_sport_status"),
    3: .standard(proto: "m_sport_speed"),
    4: .standard(proto: "m_sport_distance"),
    5: .standard(proto: "m_sport_calorie"),
    6: .standard(proto: "m_sport_flag"),
    7: .standard(proto: "m_sport_duration"),
    8: .standard(proto: "m_sport_second"),
    9: .standard(proto: "m_sport_step"),
  ]

  public var isInitialized: Bool {
    if self._mSportMode == nil {return false}
    if self._mSportStatus == nil {return false}
    if self._mSportSpeed == nil {return false}
    if self._mSportDistance == nil {return false}
    if self._mSportCalorie == nil {return false}
    if self._mSportFlag == nil {return false}
    if self._mSportDuration == nil {return false}
    if self._mSportSecond == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mSportMode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mSportStatus) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mSportSpeed) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._mSportDistance) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mSportCalorie) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mSportFlag) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._mSportDuration) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._mSportSecond) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._mSportStep) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mSportMode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mSportStatus {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mSportSpeed {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mSportDistance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }
    if let v = self._mSportCalorie {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mSportFlag {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._mSportDuration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._mSportSecond {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._mSportStep {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_sport_status_t, rhs: set_sport_status_t) -> Bool {
    if lhs._mSportMode != rhs._mSportMode {return false}
    if lhs._mSportStatus != rhs._mSportStatus {return false}
    if lhs._mSportSpeed != rhs._mSportSpeed {return false}
    if lhs._mSportDistance != rhs._mSportDistance {return false}
    if lhs._mSportCalorie != rhs._mSportCalorie {return false}
    if lhs._mSportFlag != rhs._mSportFlag {return false}
    if lhs._mSportDuration != rhs._mSportDuration {return false}
    if lhs._mSportSecond != rhs._mSportSecond {return false}
    if lhs._mSportStep != rhs._mSportStep {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_sport_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_sport_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_sport_mode"),
    2: .standard(proto: "m_sport_status"),
    3: .standard(proto: "m_sport_step"),
    4: .standard(proto: "m_sport_calorie"),
    5: .standard(proto: "m_sport_heart"),
  ]

  public var isInitialized: Bool {
    if self._mSportMode == nil {return false}
    if self._mSportStatus == nil {return false}
    if self._mSportStep == nil {return false}
    if self._mSportCalorie == nil {return false}
    if self._mSportHeart == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mSportMode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mSportStatus) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mSportStep) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mSportCalorie) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mSportHeart) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mSportMode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mSportStatus {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mSportStep {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mSportCalorie {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mSportHeart {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_sport_data_t, rhs: r_get_sport_data_t) -> Bool {
    if lhs._mSportMode != rhs._mSportMode {return false}
    if lhs._mSportStatus != rhs._mSportStatus {return false}
    if lhs._mSportStep != rhs._mSportStep {return false}
    if lhs._mSportCalorie != rhs._mSportCalorie {return false}
    if lhs._mSportHeart != rhs._mSportHeart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_music_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_music_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_music_ctr_code"),
    2: .standard(proto: "m_music_volume"),
    3: .standard(proto: "m_music_title"),
  ]

  public var isInitialized: Bool {
    if self._mMusicCtrCode == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mMusicCtrCode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mMusicVolume) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mMusicTitle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mMusicCtrCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mMusicVolume {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mMusicTitle {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_music_info_t, rhs: set_music_info_t) -> Bool {
    if lhs._mMusicCtrCode != rhs._mMusicCtrCode {return false}
    if lhs._mMusicVolume != rhs._mMusicVolume {return false}
    if lhs._mMusicTitle != rhs._mMusicTitle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_mtu_size_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_mtu_size_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_err_code"),
    2: .standard(proto: "m_mtu"),
  ]

  public var isInitialized: Bool {
    if self._mErrCode == nil {return false}
    if self._mMtu == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mErrCode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mMtu) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mErrCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mMtu {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_mtu_size_t, rhs: r_get_mtu_size_t) -> Bool {
    if lhs._mErrCode != rhs._mErrCode {return false}
    if lhs._mMtu != rhs._mMtu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_bin_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_bin_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_sn"),
    2: .standard(proto: "m_data"),
  ]

  public var isInitialized: Bool {
    if self._mSn == nil {return false}
    if self._mData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mSn) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._mData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mSn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_bin_data_t, rhs: set_bin_data_t) -> Bool {
    if lhs._mSn != rhs._mSn {return false}
    if lhs._mData != rhs._mData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_big_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_big_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_type"),
    2: .standard(proto: "m_data_lenth"),
    3: .standard(proto: "m_pic_id"),
    4: .standard(proto: "m_crc_code"),
  ]

  public var isInitialized: Bool {
    if self._mType == nil {return false}
    if self._mDataLenth == nil {return false}
    if self._mPicID == nil {return false}
    if self._mCrcCode == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mDataLenth) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mPicID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mCrcCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mDataLenth {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mPicID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mCrcCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_big_data_t, rhs: set_big_data_t) -> Bool {
    if lhs._mType != rhs._mType {return false}
    if lhs._mDataLenth != rhs._mDataLenth {return false}
    if lhs._mPicID != rhs._mPicID {return false}
    if lhs._mCrcCode != rhs._mCrcCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_alarms_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_alarms_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alarms"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.alarms) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alarms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alarms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alarms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_alarms_t, rhs: set_alarms_t) -> Bool {
    if lhs.alarms != rhs.alarms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_rtimehr_dur_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_rtimehr_dur_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_hr_duration"),
  ]

  public var isInitialized: Bool {
    if self._mHrDuration == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mHrDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mHrDuration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_rtimehr_dur_t, rhs: set_rtimehr_dur_t) -> Bool {
    if lhs._mHrDuration != rhs._mHrDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_rtimehr_value_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_rtimehr_value_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_hr_value"),
  ]

  public var isInitialized: Bool {
    if self._mHrValue == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mHrValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mHrValue {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_rtimehr_value_t, rhs: r_rtimehr_value_t) -> Bool {
    if lhs._mHrValue != rhs._mHrValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_error_code_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_error_code_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "err"),
  ]

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._err {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_error_code_t, rhs: r_error_code_t) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_find_phone_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_find_phone_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_ring_status"),
  ]

  public var isInitialized: Bool {
    if self._mRingStatus == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mRingStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mRingStatus {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_find_phone_t, rhs: r_find_phone_t) -> Bool {
    if lhs._mRingStatus != rhs._mRingStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_disturb_en_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_disturb_en_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_disturb_en"),
  ]

  public var isInitialized: Bool {
    if self._mDisturbEn == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mDisturbEn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mDisturbEn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_disturb_en_t, rhs: r_get_disturb_en_t) -> Bool {
    if lhs._mDisturbEn != rhs._mDisturbEn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_step_count_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_step_count_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_step_count"),
    2: .standard(proto: "m_time_second"),
    3: .standard(proto: "m_step_calorie"),
    4: .standard(proto: "m_step_distance"),
    5: .standard(proto: "m_activeduration"),
  ]

  public var isInitialized: Bool {
    if self._mStepCount == nil {return false}
    if self._mTimeSecond == nil {return false}
    if self._mStepCalorie == nil {return false}
    if self._mStepDistance == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mStepCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mTimeSecond) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mStepCalorie) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mStepDistance) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mActiveduration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mStepCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mTimeSecond {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mStepCalorie {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mStepDistance {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mActiveduration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_step_count_t, rhs: r_get_step_count_t) -> Bool {
    if lhs._mStepCount != rhs._mStepCount {return false}
    if lhs._mTimeSecond != rhs._mTimeSecond {return false}
    if lhs._mStepCalorie != rhs._mStepCalorie {return false}
    if lhs._mStepDistance != rhs._mStepDistance {return false}
    if lhs._mActiveduration != rhs._mActiveduration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_current_hr_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_current_hr_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_current_hr"),
    2: .standard(proto: "m_cur_sport_status"),
    3: .standard(proto: "m_step"),
    4: .standard(proto: "m_calories_kcal"),
    5: .standard(proto: "m_distance_m"),
    6: .standard(proto: "m_time_second"),
    7: .standard(proto: "m_space_skm"),
  ]

  public var isInitialized: Bool {
    if self._mCurrentHr == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mCurrentHr) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mCurSportStatus) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mStep) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mCaloriesKcal) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mDistanceM) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mTimeSecond) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._mSpaceSkm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mCurrentHr {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mCurSportStatus {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mStep {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mCaloriesKcal {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mDistanceM {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mTimeSecond {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._mSpaceSkm {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_current_hr_t, rhs: r_get_current_hr_t) -> Bool {
    if lhs._mCurrentHr != rhs._mCurrentHr {return false}
    if lhs._mCurSportStatus != rhs._mCurSportStatus {return false}
    if lhs._mStep != rhs._mStep {return false}
    if lhs._mCaloriesKcal != rhs._mCaloriesKcal {return false}
    if lhs._mDistanceM != rhs._mDistanceM {return false}
    if lhs._mTimeSecond != rhs._mTimeSecond {return false}
    if lhs._mSpaceSkm != rhs._mSpaceSkm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_set_light_leak_result_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_set_light_leak_result_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_check_result"),
  ]

  public var isInitialized: Bool {
    if self._mCheckResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mCheckResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mCheckResult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_set_light_leak_result_t, rhs: r_set_light_leak_result_t) -> Bool {
    if lhs._mCheckResult != rhs._mCheckResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_log_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_log_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_log_length"),
    2: .standard(proto: "m_log_sn"),
    3: .standard(proto: "m_log_data"),
  ]

  public var isInitialized: Bool {
    if self._mLogLength == nil {return false}
    if self._mLogSn == nil {return false}
    if self._mLogData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mLogLength) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mLogSn) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mLogData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mLogLength {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mLogSn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mLogData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_log_info_t, rhs: r_get_log_info_t) -> Bool {
    if lhs._mLogLength != rhs._mLogLength {return false}
    if lhs._mLogSn != rhs._mLogSn {return false}
    if lhs._mLogData != rhs._mLogData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_set_active_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_set_active_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_act_start_time"),
    2: .standard(proto: "m_act_end_time"),
  ]

  public var isInitialized: Bool {
    if self._mActStartTime == nil {return false}
    if self._mActEndTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mActStartTime) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mActEndTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mActStartTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mActEndTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_set_active_info_t, rhs: r_set_active_info_t) -> Bool {
    if lhs._mActStartTime != rhs._mActStartTime {return false}
    if lhs._mActEndTime != rhs._mActEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_active_record_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_active_record_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_count_num"),
    2: .standard(proto: "m_total_length"),
    3: .standard(proto: "m_active_start_second"),
    4: .standard(proto: "m_active_hr_count"),
    5: .standard(proto: "m_active_type"),
    6: .standard(proto: "m_active_step"),
    7: .standard(proto: "m_active_durations"),
    8: .standard(proto: "m_active_calories"),
    9: .standard(proto: "m_active_distance"),
    10: .standard(proto: "m_active_avg_hr"),
    11: .standard(proto: "m_active_max_hr"),
    12: .standard(proto: "m_burn_fat_mins"),
    13: .standard(proto: "m_aerobic_mins"),
    14: .standard(proto: "m_limit_mins"),
    15: .standard(proto: "m_is_effective"),
    16: .standard(proto: "m_magic_num"),
    17: .standard(proto: "m_sn"),
    18: .standard(proto: "m_hr_data"),
    19: .standard(proto: "m_active_speed"),
    20: .standard(proto: "m_active_swing"),
    21: .standard(proto: "m_active_min_hr"),
    22: .standard(proto: "m_active_skip_times"),
    23: .standard(proto: "m_active_gps_count"),
    24: .standard(proto: "m_total_gps_num"),
  ]

  fileprivate class _StorageClass {
    var _mCountNum: UInt32? = nil
    var _mTotalLength: UInt32? = nil
    var _mActiveStartSecond: UInt32? = nil
    var _mActiveHrCount: UInt32? = nil
    var _mActiveType: UInt32? = nil
    var _mActiveStep: UInt32? = nil
    var _mActiveDurations: UInt32? = nil
    var _mActiveCalories: UInt32? = nil
    var _mActiveDistance: UInt32? = nil
    var _mActiveAvgHr: UInt32? = nil
    var _mActiveMaxHr: UInt32? = nil
    var _mBurnFatMins: UInt32? = nil
    var _mAerobicMins: UInt32? = nil
    var _mLimitMins: UInt32? = nil
    var _mIsEffective: UInt32? = nil
    var _mMagicNum: UInt32? = nil
    var _mSn: UInt32? = nil
    var _mHrData: Data? = nil
    var _mActiveSpeed: UInt32? = nil
    var _mActiveSwing: UInt32? = nil
    var _mActiveMinHr: UInt32? = nil
    var _mActiveSkipTimes: UInt32? = nil
    var _mActiveGpsCount: UInt32? = nil
    var _mTotalGpsNum: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mCountNum = source._mCountNum
      _mTotalLength = source._mTotalLength
      _mActiveStartSecond = source._mActiveStartSecond
      _mActiveHrCount = source._mActiveHrCount
      _mActiveType = source._mActiveType
      _mActiveStep = source._mActiveStep
      _mActiveDurations = source._mActiveDurations
      _mActiveCalories = source._mActiveCalories
      _mActiveDistance = source._mActiveDistance
      _mActiveAvgHr = source._mActiveAvgHr
      _mActiveMaxHr = source._mActiveMaxHr
      _mBurnFatMins = source._mBurnFatMins
      _mAerobicMins = source._mAerobicMins
      _mLimitMins = source._mLimitMins
      _mIsEffective = source._mIsEffective
      _mMagicNum = source._mMagicNum
      _mSn = source._mSn
      _mHrData = source._mHrData
      _mActiveSpeed = source._mActiveSpeed
      _mActiveSwing = source._mActiveSwing
      _mActiveMinHr = source._mActiveMinHr
      _mActiveSkipTimes = source._mActiveSkipTimes
      _mActiveGpsCount = source._mActiveGpsCount
      _mTotalGpsNum = source._mTotalGpsNum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mCountNum == nil {return false}
      if _storage._mTotalLength == nil {return false}
      if _storage._mActiveStartSecond == nil {return false}
      if _storage._mActiveHrCount == nil {return false}
      if _storage._mActiveType == nil {return false}
      if _storage._mActiveStep == nil {return false}
      if _storage._mActiveDurations == nil {return false}
      if _storage._mActiveCalories == nil {return false}
      if _storage._mActiveDistance == nil {return false}
      if _storage._mActiveAvgHr == nil {return false}
      if _storage._mActiveMaxHr == nil {return false}
      if _storage._mBurnFatMins == nil {return false}
      if _storage._mAerobicMins == nil {return false}
      if _storage._mLimitMins == nil {return false}
      if _storage._mIsEffective == nil {return false}
      if _storage._mMagicNum == nil {return false}
      if _storage._mSn == nil {return false}
      if _storage._mHrData == nil {return false}
      if _storage._mActiveSpeed == nil {return false}
      if _storage._mActiveSwing == nil {return false}
      if _storage._mActiveMinHr == nil {return false}
      if _storage._mActiveSkipTimes == nil {return false}
      if _storage._mActiveGpsCount == nil {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._mCountNum) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._mTotalLength) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveStartSecond) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveHrCount) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveType) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveStep) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveDurations) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveCalories) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveDistance) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveAvgHr) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveMaxHr) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._mBurnFatMins) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._mAerobicMins) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._mLimitMins) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._mIsEffective) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._mMagicNum) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._mSn) }()
        case 18: try { try decoder.decodeSingularBytesField(value: &_storage._mHrData) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveSpeed) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveSwing) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveMinHr) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveSkipTimes) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._mActiveGpsCount) }()
        case 24: try { try decoder.decodeSingularUInt32Field(value: &_storage._mTotalGpsNum) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mCountNum {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._mTotalLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._mActiveStartSecond {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._mActiveHrCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._mActiveType {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._mActiveStep {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._mActiveDurations {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._mActiveCalories {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._mActiveDistance {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._mActiveAvgHr {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      }
      if let v = _storage._mActiveMaxHr {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._mBurnFatMins {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      }
      if let v = _storage._mAerobicMins {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      }
      if let v = _storage._mLimitMins {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
      }
      if let v = _storage._mIsEffective {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
      }
      if let v = _storage._mMagicNum {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
      }
      if let v = _storage._mSn {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 17)
      }
      if let v = _storage._mHrData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 18)
      }
      if let v = _storage._mActiveSpeed {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 19)
      }
      if let v = _storage._mActiveSwing {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 20)
      }
      if let v = _storage._mActiveMinHr {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 21)
      }
      if let v = _storage._mActiveSkipTimes {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 22)
      }
      if let v = _storage._mActiveGpsCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
      }
      if let v = _storage._mTotalGpsNum {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_active_record_data_t, rhs: r_get_active_record_data_t) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mCountNum != rhs_storage._mCountNum {return false}
        if _storage._mTotalLength != rhs_storage._mTotalLength {return false}
        if _storage._mActiveStartSecond != rhs_storage._mActiveStartSecond {return false}
        if _storage._mActiveHrCount != rhs_storage._mActiveHrCount {return false}
        if _storage._mActiveType != rhs_storage._mActiveType {return false}
        if _storage._mActiveStep != rhs_storage._mActiveStep {return false}
        if _storage._mActiveDurations != rhs_storage._mActiveDurations {return false}
        if _storage._mActiveCalories != rhs_storage._mActiveCalories {return false}
        if _storage._mActiveDistance != rhs_storage._mActiveDistance {return false}
        if _storage._mActiveAvgHr != rhs_storage._mActiveAvgHr {return false}
        if _storage._mActiveMaxHr != rhs_storage._mActiveMaxHr {return false}
        if _storage._mBurnFatMins != rhs_storage._mBurnFatMins {return false}
        if _storage._mAerobicMins != rhs_storage._mAerobicMins {return false}
        if _storage._mLimitMins != rhs_storage._mLimitMins {return false}
        if _storage._mIsEffective != rhs_storage._mIsEffective {return false}
        if _storage._mMagicNum != rhs_storage._mMagicNum {return false}
        if _storage._mSn != rhs_storage._mSn {return false}
        if _storage._mHrData != rhs_storage._mHrData {return false}
        if _storage._mActiveSpeed != rhs_storage._mActiveSpeed {return false}
        if _storage._mActiveSwing != rhs_storage._mActiveSwing {return false}
        if _storage._mActiveMinHr != rhs_storage._mActiveMinHr {return false}
        if _storage._mActiveSkipTimes != rhs_storage._mActiveSkipTimes {return false}
        if _storage._mActiveGpsCount != rhs_storage._mActiveGpsCount {return false}
        if _storage._mTotalGpsNum != rhs_storage._mTotalGpsNum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_ui_hrs_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_ui_hrs_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_ui_act_hr"),
    2: .standard(proto: "m_ui_max_hr"),
    3: .standard(proto: "m_ui_min_hr"),
  ]

  public var isInitialized: Bool {
    if self._mUiActHr == nil {return false}
    if self._mUiMaxHr == nil {return false}
    if self._mUiMinHr == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mUiActHr) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mUiMaxHr) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mUiMinHr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mUiActHr {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mUiMaxHr {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mUiMinHr {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_ui_hrs_t, rhs: r_get_ui_hrs_t) -> Bool {
    if lhs._mUiActHr != rhs._mUiActHr {return false}
    if lhs._mUiMaxHr != rhs._mUiMaxHr {return false}
    if lhs._mUiMinHr != rhs._mUiMinHr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_nfc_operate_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = "set_nfc_operate_t"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_nfc_operate_code"),
    2: .standard(proto: "m_nfc_data"),
    3: .standard(proto: "m_nfc_err_code"),
    4: .standard(proto: "m_nfc_sub_operate_code"),
    5: .standard(proto: "m_nfc_city"),
  ]

  public var isInitialized: Bool {
    if self._mNfcOperateCode == nil {return false}
    if self._mNfcData == nil {return false}
    if self._mNfcErrCode == nil {return false}
    return true
  }

    public  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mNfcOperateCode) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._mNfcData) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mNfcErrCode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mNfcSubOperateCode) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._mNfcCity) }()
      default: break
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mNfcOperateCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mNfcData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._mNfcErrCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mNfcSubOperateCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mNfcCity {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: set_nfc_operate_t, rhs: set_nfc_operate_t) -> Bool {
    if lhs._mNfcOperateCode != rhs._mNfcOperateCode {return false}
    if lhs._mNfcData != rhs._mNfcData {return false}
    if lhs._mNfcErrCode != rhs._mNfcErrCode {return false}
    if lhs._mNfcSubOperateCode != rhs._mNfcSubOperateCode {return false}
    if lhs._mNfcCity != rhs._mNfcCity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_page_switch_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_page_switch_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_operate_type"),
    2: .standard(proto: "m_page_switch"),
  ]

  public var isInitialized: Bool {
    if self._mOperateType == nil {return false}
    if self._mPageSwitch == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mOperateType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mPageSwitch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mOperateType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mPageSwitch {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_page_switch_t, rhs: set_page_switch_t) -> Bool {
    if lhs._mOperateType != rhs._mOperateType {return false}
    if lhs._mPageSwitch != rhs._mPageSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_check_gps_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_check_gps_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_check_type"),
    2: .standard(proto: "m_file_num"),
    3: .standard(proto: "m_second"),
    4: .standard(proto: "m_new_version"),
  ]

  public var isInitialized: Bool {
    if self._mCheckType == nil {return false}
    if self._mFileNum == nil {return false}
    if self._mSecond == nil {return false}
    if self._mNewVersion == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mCheckType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mFileNum) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mSecond) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mNewVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mCheckType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mFileNum {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mSecond {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mNewVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_check_gps_info_t, rhs: set_check_gps_info_t) -> Bool {
    if lhs._mCheckType != rhs._mCheckType {return false}
    if lhs._mFileNum != rhs._mFileNum {return false}
    if lhs._mSecond != rhs._mSecond {return false}
    if lhs._mNewVersion != rhs._mNewVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_update_gps_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_update_gps_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_file_name"),
    2: .standard(proto: "m_file_length"),
    3: .standard(proto: "m_sn"),
    4: .standard(proto: "m_data"),
  ]

  public var isInitialized: Bool {
    if self._mFileName == nil {return false}
    if self._mFileLength == nil {return false}
    if self._mSn == nil {return false}
    if self._mData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mFileName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mFileLength) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mSn) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._mData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mFileName {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mFileLength {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mSn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_update_gps_data_t, rhs: set_update_gps_data_t) -> Bool {
    if lhs._mFileName != rhs._mFileName {return false}
    if lhs._mFileLength != rhs._mFileLength {return false}
    if lhs._mSn != rhs._mSn {return false}
    if lhs._mData != rhs._mData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_update_spo2_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_update_spo2_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_spo2_value"),
    2: .standard(proto: "m_seconds"),
  ]

  public var isInitialized: Bool {
    if self._mSpo2Value == nil {return false}
    if self._mSeconds == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mSpo2Value) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mSpo2Value {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mSeconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_update_spo2_data_t, rhs: set_update_spo2_data_t) -> Bool {
    if lhs._mSpo2Value != rhs._mSpo2Value {return false}
    if lhs._mSeconds != rhs._mSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension get_dial_config_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "get_dial_config_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_dial_id"),
    2: .standard(proto: "m_dial_width"),
    3: .standard(proto: "m_dial_height"),
    4: .standard(proto: "m_dial_form"),
    5: .standard(proto: "m_dial_max_size"),
  ]

  public var isInitialized: Bool {
    if self._mDialID == nil {return false}
    if self._mDialWidth == nil {return false}
    if self._mDialHeight == nil {return false}
    if self._mDialForm == nil {return false}
    if self._mDialMaxSize == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mDialID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mDialWidth) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mDialHeight) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mDialForm) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mDialMaxSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mDialID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mDialWidth {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mDialHeight {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mDialForm {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mDialMaxSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: get_dial_config_data_t, rhs: get_dial_config_data_t) -> Bool {
    if lhs._mDialID != rhs._mDialID {return false}
    if lhs._mDialWidth != rhs._mDialWidth {return false}
    if lhs._mDialHeight != rhs._mDialHeight {return false}
    if lhs._mDialForm != rhs._mDialForm {return false}
    if lhs._mDialMaxSize != rhs._mDialMaxSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_warming_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_warming_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_type"),
    2: .standard(proto: "m_min"),
    3: .standard(proto: "m_max"),
  ]

  public var isInitialized: Bool {
    if self._mType == nil {return false}
    if self._mMin == nil {return false}
    if self._mMax == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mMin) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mMax) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mMin {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mMax {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_warming_data_t, rhs: set_warming_data_t) -> Bool {
    if lhs._mType != rhs._mType {return false}
    if lhs._mMin != rhs._mMin {return false}
    if lhs._mMax != rhs._mMax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_menu_sequence_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_menu_sequence_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_type"),
    2: .standard(proto: "m_count"),
    3: .standard(proto: "m_data"),
  ]

  public var isInitialized: Bool {
    if self._mType == nil {return false}
    if self._mCount == nil {return false}
    if self._mData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mCount) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_menu_sequence_t, rhs: set_menu_sequence_t) -> Bool {
    if lhs._mType != rhs._mType {return false}
    if lhs._mCount != rhs._mCount {return false}
    if lhs._mData != rhs._mData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension get_menu_sequence_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "get_menu_sequence_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_type"),
  ]

  public var isInitialized: Bool {
    if self._mType == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: get_menu_sequence_t, rhs: get_menu_sequence_t) -> Bool {
    if lhs._mType != rhs._mType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_menu_sequence_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_menu_sequence_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_type"),
    2: .standard(proto: "m_support_count"),
    3: .standard(proto: "m_support"),
    4: .standard(proto: "m_count"),
    5: .standard(proto: "m_data"),
  ]

  public var isInitialized: Bool {
    if self._mType == nil {return false}
    if self._mSupportCount == nil {return false}
    if self._mSupport == nil {return false}
    if self._mCount == nil {return false}
    if self._mData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mSupportCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mSupport) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mCount) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._mData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mSupportCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mSupport {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_menu_sequence_t, rhs: r_get_menu_sequence_t) -> Bool {
    if lhs._mType != rhs._mType {return false}
    if lhs._mSupportCount != rhs._mSupportCount {return false}
    if lhs._mSupport != rhs._mSupport {return false}
    if lhs._mCount != rhs._mCount {return false}
    if lhs._mData != rhs._mData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension get_nfc_card_data_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "get_nfc_card_data_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_data"),
  ]

  public var isInitialized: Bool {
    if self._mData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._mData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: get_nfc_card_data_t, rhs: get_nfc_card_data_t) -> Bool {
    if lhs._mData != rhs._mData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_spo2_detect_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_spo2_detect_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_night_enable"),
    2: .standard(proto: "m_night_intersec"),
  ]

  public var isInitialized: Bool {
    if self._mNightEnable == nil {return false}
    if self._mNightIntersec == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mNightEnable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mNightIntersec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mNightEnable {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mNightIntersec {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_spo2_detect_t, rhs: set_spo2_detect_t) -> Bool {
    if lhs._mNightEnable != rhs._mNightEnable {return false}
    if lhs._mNightIntersec != rhs._mNightIntersec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension r_get_spo2_detect_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "r_get_spo2_detect_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_night_enable"),
    2: .standard(proto: "m_night_intersec"),
  ]

  public var isInitialized: Bool {
    if self._mNightEnable == nil {return false}
    if self._mNightIntersec == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mNightEnable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mNightIntersec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mNightEnable {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mNightIntersec {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: r_get_spo2_detect_t, rhs: r_get_spo2_detect_t) -> Bool {
    if lhs._mNightEnable != rhs._mNightEnable {return false}
    if lhs._mNightIntersec != rhs._mNightIntersec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension swsn_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "swsn_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "swsn"),
    2: .standard(proto: "func_switch"),
    3: .standard(proto: "langs_switch"),
    4: .standard(proto: "default_lang"),
    5: .standard(proto: "project_num"),
  ]

  public var isInitialized: Bool {
    if self._swsn == nil {return false}
    if self._funcSwitch == nil {return false}
    if self._langsSwitch == nil {return false}
    if self._defaultLang == nil {return false}
    if self._projectNum == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._swsn) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._funcSwitch) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._langsSwitch) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._defaultLang) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._projectNum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._swsn {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._funcSwitch {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._langsSwitch {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._defaultLang {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._projectNum {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: swsn_info_t, rhs: swsn_info_t) -> Bool {
    if lhs._swsn != rhs._swsn {return false}
    if lhs._funcSwitch != rhs._funcSwitch {return false}
    if lhs._langsSwitch != rhs._langsSwitch {return false}
    if lhs._defaultLang != rhs._defaultLang {return false}
    if lhs._projectNum != rhs._projectNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_phone_app_status_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_phone_app_status_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_status"),
  ]

  public var isInitialized: Bool {
    if self._mStatus == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mStatus {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_phone_app_status_t, rhs: set_phone_app_status_t) -> Bool {
    if lhs._mStatus != rhs._mStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension set_female_health_info_t: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "set_female_health_info_t"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "m_duration"),
    2: .standard(proto: "m_period"),
    3: .standard(proto: "m_last_year"),
    4: .standard(proto: "m_last_month"),
    5: .standard(proto: "m_last_day"),
    6: .standard(proto: "m_set_timestamps"),
    7: .standard(proto: "m_set_year"),
    8: .standard(proto: "m_set_month"),
    9: .standard(proto: "m_set_day"),
    10: .standard(proto: "m_check"),
  ]

  public var isInitialized: Bool {
    if self._mDuration == nil {return false}
    if self._mPeriod == nil {return false}
    if self._mLastYear == nil {return false}
    if self._mLastMonth == nil {return false}
    if self._mLastDay == nil {return false}
    if self._mSetTimestamps == nil {return false}
    if self._mSetYear == nil {return false}
    if self._mSetMonth == nil {return false}
    if self._mSetDay == nil {return false}
    if self._mCheck == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._mDuration) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._mPeriod) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mLastYear) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mLastMonth) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._mLastDay) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mSetTimestamps) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._mSetYear) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._mSetMonth) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._mSetDay) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._mCheck) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mDuration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._mPeriod {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mLastYear {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mLastMonth {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mLastDay {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._mSetTimestamps {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._mSetYear {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._mSetMonth {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._mSetDay {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._mCheck {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: set_female_health_info_t, rhs: set_female_health_info_t) -> Bool {
    if lhs._mDuration != rhs._mDuration {return false}
    if lhs._mPeriod != rhs._mPeriod {return false}
    if lhs._mLastYear != rhs._mLastYear {return false}
    if lhs._mLastMonth != rhs._mLastMonth {return false}
    if lhs._mLastDay != rhs._mLastDay {return false}
    if lhs._mSetTimestamps != rhs._mSetTimestamps {return false}
    if lhs._mSetYear != rhs._mSetYear {return false}
    if lhs._mSetMonth != rhs._mSetMonth {return false}
    if lhs._mSetDay != rhs._mSetDay {return false}
    if lhs._mCheck != rhs._mCheck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension hl_cmds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = "hl_cmds"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cmd"),
    2: .same(proto: "response"),
    3: .same(proto: "seconds"),
    45: .same(proto: "timezone"),
    4: .standard(proto: "set_app_info"),
    5: .standard(proto: "r_bind_device"),
    6: .standard(proto: "r_get_device_info"),
    7: .standard(proto: "sync_phone_info"),
    8: .standard(proto: "sync_user_info"),
    9: .standard(proto: "sync_switch"),
    10: .standard(proto: "set_hr_sample_slot"),
    11: .standard(proto: "set_longsit_duration"),
    12: .standard(proto: "set_drink_slot"),
    13: .standard(proto: "set_alarms"),
    14: .standard(proto: "set_notdisturb"),
    15: .standard(proto: "set_country_info"),
    16: .standard(proto: "set_ui_style"),
    17: .standard(proto: "set_sport_target"),
    18: .standard(proto: "set_time_format"),
    19: .standard(proto: "set_metric_inch"),
    20: .standard(proto: "set_bright_times"),
    21: .standard(proto: "set_set_hr_warning"),
    22: .standard(proto: "r_get_hr_value"),
    23: .standard(proto: "set_notify_warn_info"),
    24: .standard(proto: "set_health_data_info"),
    25: .standard(proto: "r_get_power_value"),
    26: .standard(proto: "set_updata_fw"),
    27: .standard(proto: "set_weather_info"),
    28: .standard(proto: "set_reset_machine"),
    29: .standard(proto: "set_sport_status"),
    30: .standard(proto: "r_get_health_data"),
    31: .standard(proto: "set_music_info"),
    32: .standard(proto: "r_get_mtu_size"),
    33: .standard(proto: "set_bin_data"),
    34: .standard(proto: "set_big_data"),
    35: .standard(proto: "r_find_phone"),
    36: .standard(proto: "set_hr_dur"),
    37: .standard(proto: "r_hr_value"),
    38: .standard(proto: "r_get_sprot_data"),
    39: .standard(proto: "r_get_disturb_en"),
    40: .standard(proto: "r_get_step_count"),
    41: .standard(proto: "r_get_current_hr"),
    42: .standard(proto: "r_set_light_result"),
    43: .standard(proto: "r_get_active_record"),
    44: .standard(proto: "r_set_active_info"),
    46: .standard(proto: "r_get_log_info"),
    47: .standard(proto: "r_get_ui_hrs"),
    48: .standard(proto: "r_error_code"),
    49: .standard(proto: "set_nfc_operate"),
    50: .standard(proto: "set_page_switch"),
    51: .standard(proto: "set_check_gps_info"),
    52: .standard(proto: "set_update_gps_data"),
    53: .standard(proto: "set_update_spo2_data"),
    54: .standard(proto: "get_dial_config_data"),
    55: .standard(proto: "set_warming_data"),
    56: .standard(proto: "set_menu_seq_data"),
    57: .standard(proto: "get_menu_seq_data"),
    58: .standard(proto: "r_get_menu_seq_data"),
    59: .standard(proto: "get_nfc_card_data"),
    60: .standard(proto: "set_spo2_detect"),
    61: .standard(proto: "r_get_spo2_detect"),
    62: .standard(proto: "swsn_info"),
    63: .standard(proto: "set_phone_app_status"),
    64: .standard(proto: "set_female_health_info"),
  ]

  fileprivate class _StorageClass {
    var _cmd: hl_cmds.cmd_t? = nil
    var _response: Bool? = nil
    var _seconds: UInt32? = nil
    var _timezone: Int32? = nil
    var _setAppInfo: bind_app_info_t? = nil
    var _rBindDevice: r_bind_device_t? = nil
    var _rGetDeviceInfo: r_get_device_info_t? = nil
    var _syncPhoneInfo: sync_phone_info_t? = nil
    var _syncUserInfo: sync_user_info_t? = nil
    var _syncSwitch: sync_switch_t? = nil
    var _setHrSampleSlot: set_hr_sample_slot_t? = nil
    var _setLongsitDuration: set_longsit_duration_t? = nil
    var _setDrinkSlot: set_drink_slot_t? = nil
    var _setAlarms: set_alarms_t? = nil
    var _setNotdisturb: set_notdisturb_t? = nil
    var _setCountryInfo: set_country_info_t? = nil
    var _setUiStyle: set_ui_style_t? = nil
    var _setSportTarget: set_sport_target_t? = nil
    var _setTimeFormat: set_time_format_t? = nil
    var _setMetricInch: set_metric_inch_t? = nil
    var _setBrightTimes: set_bright_times_t? = nil
    var _setSetHrWarning: set_hr_warning_t? = nil
    var _rGetHrValue: r_get_hr_value_t? = nil
    var _setNotifyWarnInfo: set_notify_warning_t? = nil
    var _setHealthDataInfo: r_sync_health_data_t? = nil
    var _rGetPowerValue: r_get_power_t? = nil
    var _setUpdataFw: set_updata_fw_t? = nil
    var _setWeatherInfo: set_weather_info_t? = nil
    var _setResetMachine: set_reset_machine_t? = nil
    var _setSportStatus: set_sport_status_t? = nil
    var _rGetHealthData: r_get_health_data_t? = nil
    var _setMusicInfo: set_music_info_t? = nil
    var _rGetMtuSize: r_get_mtu_size_t? = nil
    var _setBinData: set_bin_data_t? = nil
    var _setBigData: set_big_data_t? = nil
    var _rFindPhone: r_find_phone_t? = nil
    var _setHrDur: set_rtimehr_dur_t? = nil
    var _rHrValue: r_rtimehr_value_t? = nil
    var _rGetSprotData: r_get_sport_data_t? = nil
    var _rGetDisturbEn: r_get_disturb_en_t? = nil
    var _rGetStepCount: r_get_step_count_t? = nil
    var _rGetCurrentHr: r_get_current_hr_t? = nil
    var _rSetLightResult: r_set_light_leak_result_t? = nil
    var _rGetActiveRecord: r_get_active_record_data_t? = nil
    var _rSetActiveInfo: r_set_active_info_t? = nil
    var _rGetLogInfo: r_get_log_info_t? = nil
    var _rGetUiHrs: r_get_ui_hrs_t? = nil
    var _rErrorCode: r_error_code_t? = nil
    var _setNfcOperate: set_nfc_operate_t? = nil
    var _setPageSwitch: set_page_switch_t? = nil
    var _setCheckGpsInfo: set_check_gps_info_t? = nil
    var _setUpdateGpsData: set_update_gps_data_t? = nil
    var _setUpdateSpo2Data: set_update_spo2_data_t? = nil
    var _getDialConfigData: get_dial_config_data_t? = nil
    var _setWarmingData: set_warming_data_t? = nil
    var _setMenuSeqData: set_menu_sequence_t? = nil
    var _getMenuSeqData: get_menu_sequence_t? = nil
    var _rGetMenuSeqData: r_get_menu_sequence_t? = nil
    var _getNfcCardData: get_nfc_card_data_t? = nil
    var _setSpo2Detect: set_spo2_detect_t? = nil
    var _rGetSpo2Detect: r_get_spo2_detect_t? = nil
    var _swsnInfo: swsn_info_t? = nil
    var _setPhoneAppStatus: set_phone_app_status_t? = nil
    var _setFemaleHealthInfo: set_female_health_info_t? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cmd = source._cmd
      _response = source._response
      _seconds = source._seconds
      _timezone = source._timezone
      _setAppInfo = source._setAppInfo
      _rBindDevice = source._rBindDevice
      _rGetDeviceInfo = source._rGetDeviceInfo
      _syncPhoneInfo = source._syncPhoneInfo
      _syncUserInfo = source._syncUserInfo
      _syncSwitch = source._syncSwitch
      _setHrSampleSlot = source._setHrSampleSlot
      _setLongsitDuration = source._setLongsitDuration
      _setDrinkSlot = source._setDrinkSlot
      _setAlarms = source._setAlarms
      _setNotdisturb = source._setNotdisturb
      _setCountryInfo = source._setCountryInfo
      _setUiStyle = source._setUiStyle
      _setSportTarget = source._setSportTarget
      _setTimeFormat = source._setTimeFormat
      _setMetricInch = source._setMetricInch
      _setBrightTimes = source._setBrightTimes
      _setSetHrWarning = source._setSetHrWarning
      _rGetHrValue = source._rGetHrValue
      _setNotifyWarnInfo = source._setNotifyWarnInfo
      _setHealthDataInfo = source._setHealthDataInfo
      _rGetPowerValue = source._rGetPowerValue
      _setUpdataFw = source._setUpdataFw
      _setWeatherInfo = source._setWeatherInfo
      _setResetMachine = source._setResetMachine
      _setSportStatus = source._setSportStatus
      _rGetHealthData = source._rGetHealthData
      _setMusicInfo = source._setMusicInfo
      _rGetMtuSize = source._rGetMtuSize
      _setBinData = source._setBinData
      _setBigData = source._setBigData
      _rFindPhone = source._rFindPhone
      _setHrDur = source._setHrDur
      _rHrValue = source._rHrValue
      _rGetSprotData = source._rGetSprotData
      _rGetDisturbEn = source._rGetDisturbEn
      _rGetStepCount = source._rGetStepCount
      _rGetCurrentHr = source._rGetCurrentHr
      _rSetLightResult = source._rSetLightResult
      _rGetActiveRecord = source._rGetActiveRecord
      _rSetActiveInfo = source._rSetActiveInfo
      _rGetLogInfo = source._rGetLogInfo
      _rGetUiHrs = source._rGetUiHrs
      _rErrorCode = source._rErrorCode
      _setNfcOperate = source._setNfcOperate
      _setPageSwitch = source._setPageSwitch
      _setCheckGpsInfo = source._setCheckGpsInfo
      _setUpdateGpsData = source._setUpdateGpsData
      _setUpdateSpo2Data = source._setUpdateSpo2Data
      _getDialConfigData = source._getDialConfigData
      _setWarmingData = source._setWarmingData
      _setMenuSeqData = source._setMenuSeqData
      _getMenuSeqData = source._getMenuSeqData
      _rGetMenuSeqData = source._rGetMenuSeqData
      _getNfcCardData = source._getNfcCardData
      _setSpo2Detect = source._setSpo2Detect
      _rGetSpo2Detect = source._rGetSpo2Detect
      _swsnInfo = source._swsnInfo
      _setPhoneAppStatus = source._setPhoneAppStatus
      _setFemaleHealthInfo = source._setFemaleHealthInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._cmd == nil {return false}
      if _storage._response == nil {return false}
      if _storage._seconds == nil {return false}
      if _storage._timezone == nil {return false}
      if let v = _storage._setAppInfo, !v.isInitialized {return false}
      if let v = _storage._rBindDevice, !v.isInitialized {return false}
      if let v = _storage._rGetDeviceInfo, !v.isInitialized {return false}
      if let v = _storage._syncPhoneInfo, !v.isInitialized {return false}
      if let v = _storage._syncUserInfo, !v.isInitialized {return false}
      if let v = _storage._syncSwitch, !v.isInitialized {return false}
      if let v = _storage._setHrSampleSlot, !v.isInitialized {return false}
      if let v = _storage._setLongsitDuration, !v.isInitialized {return false}
      if let v = _storage._setDrinkSlot, !v.isInitialized {return false}
      if let v = _storage._setAlarms, !v.isInitialized {return false}
      if let v = _storage._setNotdisturb, !v.isInitialized {return false}
      if let v = _storage._setCountryInfo, !v.isInitialized {return false}
      if let v = _storage._setUiStyle, !v.isInitialized {return false}
      if let v = _storage._setSportTarget, !v.isInitialized {return false}
      if let v = _storage._setTimeFormat, !v.isInitialized {return false}
      if let v = _storage._setMetricInch, !v.isInitialized {return false}
      if let v = _storage._setBrightTimes, !v.isInitialized {return false}
      if let v = _storage._setSetHrWarning, !v.isInitialized {return false}
      if let v = _storage._rGetHrValue, !v.isInitialized {return false}
      if let v = _storage._setNotifyWarnInfo, !v.isInitialized {return false}
      if let v = _storage._setHealthDataInfo, !v.isInitialized {return false}
      if let v = _storage._rGetPowerValue, !v.isInitialized {return false}
      if let v = _storage._setUpdataFw, !v.isInitialized {return false}
      if let v = _storage._setWeatherInfo, !v.isInitialized {return false}
      if let v = _storage._setResetMachine, !v.isInitialized {return false}
      if let v = _storage._setSportStatus, !v.isInitialized {return false}
      if let v = _storage._rGetHealthData, !v.isInitialized {return false}
      if let v = _storage._setMusicInfo, !v.isInitialized {return false}
      if let v = _storage._rGetMtuSize, !v.isInitialized {return false}
      if let v = _storage._setBinData, !v.isInitialized {return false}
      if let v = _storage._setBigData, !v.isInitialized {return false}
      if let v = _storage._rFindPhone, !v.isInitialized {return false}
      if let v = _storage._setHrDur, !v.isInitialized {return false}
      if let v = _storage._rHrValue, !v.isInitialized {return false}
      if let v = _storage._rGetSprotData, !v.isInitialized {return false}
      if let v = _storage._rGetDisturbEn, !v.isInitialized {return false}
      if let v = _storage._rGetStepCount, !v.isInitialized {return false}
      if let v = _storage._rGetCurrentHr, !v.isInitialized {return false}
      if let v = _storage._rSetLightResult, !v.isInitialized {return false}
      if let v = _storage._rGetActiveRecord, !v.isInitialized {return false}
      if let v = _storage._rSetActiveInfo, !v.isInitialized {return false}
      if let v = _storage._rGetLogInfo, !v.isInitialized {return false}
      if let v = _storage._rGetUiHrs, !v.isInitialized {return false}
      if let v = _storage._rErrorCode, !v.isInitialized {return false}
      if let v = _storage._setNfcOperate, !v.isInitialized {return false}
      if let v = _storage._setPageSwitch, !v.isInitialized {return false}
      if let v = _storage._setCheckGpsInfo, !v.isInitialized {return false}
      if let v = _storage._setUpdateGpsData, !v.isInitialized {return false}
      if let v = _storage._setUpdateSpo2Data, !v.isInitialized {return false}
      if let v = _storage._getDialConfigData, !v.isInitialized {return false}
      if let v = _storage._setWarmingData, !v.isInitialized {return false}
      if let v = _storage._setMenuSeqData, !v.isInitialized {return false}
      if let v = _storage._getMenuSeqData, !v.isInitialized {return false}
      if let v = _storage._rGetMenuSeqData, !v.isInitialized {return false}
      if let v = _storage._getNfcCardData, !v.isInitialized {return false}
      if let v = _storage._setSpo2Detect, !v.isInitialized {return false}
      if let v = _storage._rGetSpo2Detect, !v.isInitialized {return false}
      if let v = _storage._swsnInfo, !v.isInitialized {return false}
      if let v = _storage._setPhoneAppStatus, !v.isInitialized {return false}
      if let v = _storage._setFemaleHealthInfo, !v.isInitialized {return false}
      return true
    }
  }

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._cmd) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._response) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._seconds) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._setAppInfo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._rBindDevice) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._rGetDeviceInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._syncPhoneInfo) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._syncUserInfo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._syncSwitch) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._setHrSampleSlot) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._setLongsitDuration) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._setDrinkSlot) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._setAlarms) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._setNotdisturb) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._setCountryInfo) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._setUiStyle) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._setSportTarget) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._setTimeFormat) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._setMetricInch) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._setBrightTimes) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._setSetHrWarning) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._rGetHrValue) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._setNotifyWarnInfo) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._setHealthDataInfo) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._rGetPowerValue) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._setUpdataFw) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._setWeatherInfo) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._setResetMachine) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._setSportStatus) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._rGetHealthData) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._setMusicInfo) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._rGetMtuSize) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._setBinData) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._setBigData) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._rFindPhone) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._setHrDur) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._rHrValue) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._rGetSprotData) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._rGetDisturbEn) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._rGetStepCount) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._rGetCurrentHr) }()
        case 42: try { try decoder.decodeSingularMessageField(value: &_storage._rSetLightResult) }()
        case 43: try { try decoder.decodeSingularMessageField(value: &_storage._rGetActiveRecord) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._rSetActiveInfo) }()
        case 45: try { try decoder.decodeSingularInt32Field(value: &_storage._timezone) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._rGetLogInfo) }()
        case 47: try { try decoder.decodeSingularMessageField(value: &_storage._rGetUiHrs) }()
        case 48: try { try decoder.decodeSingularMessageField(value: &_storage._rErrorCode) }()
        case 49: try { try decoder.decodeSingularMessageField(value: &_storage._setNfcOperate) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._setPageSwitch) }()
        case 51: try { try decoder.decodeSingularMessageField(value: &_storage._setCheckGpsInfo) }()
        case 52: try { try decoder.decodeSingularMessageField(value: &_storage._setUpdateGpsData) }()
        case 53: try { try decoder.decodeSingularMessageField(value: &_storage._setUpdateSpo2Data) }()
        case 54: try { try decoder.decodeSingularMessageField(value: &_storage._getDialConfigData) }()
        case 55: try { try decoder.decodeSingularMessageField(value: &_storage._setWarmingData) }()
        case 56: try { try decoder.decodeSingularMessageField(value: &_storage._setMenuSeqData) }()
        case 57: try { try decoder.decodeSingularMessageField(value: &_storage._getMenuSeqData) }()
        case 58: try { try decoder.decodeSingularMessageField(value: &_storage._rGetMenuSeqData) }()
        case 59: try { try decoder.decodeSingularMessageField(value: &_storage._getNfcCardData) }()
        case 60: try { try decoder.decodeSingularMessageField(value: &_storage._setSpo2Detect) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._rGetSpo2Detect) }()
        case 62: try { try decoder.decodeSingularMessageField(value: &_storage._swsnInfo) }()
        case 63: try { try decoder.decodeSingularMessageField(value: &_storage._setPhoneAppStatus) }()
        case 64: try { try decoder.decodeSingularMessageField(value: &_storage._setFemaleHealthInfo) }()
        default: break
        }
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._cmd {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }
      if let v = _storage._response {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._seconds {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._setAppInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._rBindDevice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._rGetDeviceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._syncPhoneInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._syncUserInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._syncSwitch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._setHrSampleSlot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._setLongsitDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._setDrinkSlot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._setAlarms {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._setNotdisturb {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._setCountryInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._setUiStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._setSportTarget {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._setTimeFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._setMetricInch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._setBrightTimes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._setSetHrWarning {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._rGetHrValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._setNotifyWarnInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._setHealthDataInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._rGetPowerValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
      if let v = _storage._setUpdataFw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if let v = _storage._setWeatherInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if let v = _storage._setResetMachine {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }
      if let v = _storage._setSportStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
      if let v = _storage._rGetHealthData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._setMusicInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._rGetMtuSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._setBinData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if let v = _storage._setBigData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }
      if let v = _storage._rFindPhone {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }
      if let v = _storage._setHrDur {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }
      if let v = _storage._rHrValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }
      if let v = _storage._rGetSprotData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }
      if let v = _storage._rGetDisturbEn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }
      if let v = _storage._rGetStepCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }
      if let v = _storage._rGetCurrentHr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }
      if let v = _storage._rSetLightResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }
      if let v = _storage._rGetActiveRecord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }
      if let v = _storage._rSetActiveInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }
      if let v = _storage._timezone {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 45)
      }
      if let v = _storage._rGetLogInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }
      if let v = _storage._rGetUiHrs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }
      if let v = _storage._rErrorCode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }
      if let v = _storage._setNfcOperate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }
      if let v = _storage._setPageSwitch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
      if let v = _storage._setCheckGpsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }
      if let v = _storage._setUpdateGpsData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }
      if let v = _storage._setUpdateSpo2Data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }
      if let v = _storage._getDialConfigData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }
      if let v = _storage._setWarmingData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      }
      if let v = _storage._setMenuSeqData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      }
      if let v = _storage._getMenuSeqData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      }
      if let v = _storage._rGetMenuSeqData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      }
      if let v = _storage._getNfcCardData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      }
      if let v = _storage._setSpo2Detect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }
      if let v = _storage._rGetSpo2Detect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      }
      if let v = _storage._swsnInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      }
      if let v = _storage._setPhoneAppStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      }
      if let v = _storage._setFemaleHealthInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: hl_cmds, rhs: hl_cmds) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cmd != rhs_storage._cmd {return false}
        if _storage._response != rhs_storage._response {return false}
        if _storage._seconds != rhs_storage._seconds {return false}
        if _storage._timezone != rhs_storage._timezone {return false}
        if _storage._setAppInfo != rhs_storage._setAppInfo {return false}
        if _storage._rBindDevice != rhs_storage._rBindDevice {return false}
        if _storage._rGetDeviceInfo != rhs_storage._rGetDeviceInfo {return false}
        if _storage._syncPhoneInfo != rhs_storage._syncPhoneInfo {return false}
        if _storage._syncUserInfo != rhs_storage._syncUserInfo {return false}
        if _storage._syncSwitch != rhs_storage._syncSwitch {return false}
        if _storage._setHrSampleSlot != rhs_storage._setHrSampleSlot {return false}
        if _storage._setLongsitDuration != rhs_storage._setLongsitDuration {return false}
        if _storage._setDrinkSlot != rhs_storage._setDrinkSlot {return false}
        if _storage._setAlarms != rhs_storage._setAlarms {return false}
        if _storage._setNotdisturb != rhs_storage._setNotdisturb {return false}
        if _storage._setCountryInfo != rhs_storage._setCountryInfo {return false}
        if _storage._setUiStyle != rhs_storage._setUiStyle {return false}
        if _storage._setSportTarget != rhs_storage._setSportTarget {return false}
        if _storage._setTimeFormat != rhs_storage._setTimeFormat {return false}
        if _storage._setMetricInch != rhs_storage._setMetricInch {return false}
        if _storage._setBrightTimes != rhs_storage._setBrightTimes {return false}
        if _storage._setSetHrWarning != rhs_storage._setSetHrWarning {return false}
        if _storage._rGetHrValue != rhs_storage._rGetHrValue {return false}
        if _storage._setNotifyWarnInfo != rhs_storage._setNotifyWarnInfo {return false}
        if _storage._setHealthDataInfo != rhs_storage._setHealthDataInfo {return false}
        if _storage._rGetPowerValue != rhs_storage._rGetPowerValue {return false}
        if _storage._setUpdataFw != rhs_storage._setUpdataFw {return false}
        if _storage._setWeatherInfo != rhs_storage._setWeatherInfo {return false}
        if _storage._setResetMachine != rhs_storage._setResetMachine {return false}
        if _storage._setSportStatus != rhs_storage._setSportStatus {return false}
        if _storage._rGetHealthData != rhs_storage._rGetHealthData {return false}
        if _storage._setMusicInfo != rhs_storage._setMusicInfo {return false}
        if _storage._rGetMtuSize != rhs_storage._rGetMtuSize {return false}
        if _storage._setBinData != rhs_storage._setBinData {return false}
        if _storage._setBigData != rhs_storage._setBigData {return false}
        if _storage._rFindPhone != rhs_storage._rFindPhone {return false}
        if _storage._setHrDur != rhs_storage._setHrDur {return false}
        if _storage._rHrValue != rhs_storage._rHrValue {return false}
        if _storage._rGetSprotData != rhs_storage._rGetSprotData {return false}
        if _storage._rGetDisturbEn != rhs_storage._rGetDisturbEn {return false}
        if _storage._rGetStepCount != rhs_storage._rGetStepCount {return false}
        if _storage._rGetCurrentHr != rhs_storage._rGetCurrentHr {return false}
        if _storage._rSetLightResult != rhs_storage._rSetLightResult {return false}
        if _storage._rGetActiveRecord != rhs_storage._rGetActiveRecord {return false}
        if _storage._rSetActiveInfo != rhs_storage._rSetActiveInfo {return false}
        if _storage._rGetLogInfo != rhs_storage._rGetLogInfo {return false}
        if _storage._rGetUiHrs != rhs_storage._rGetUiHrs {return false}
        if _storage._rErrorCode != rhs_storage._rErrorCode {return false}
        if _storage._setNfcOperate != rhs_storage._setNfcOperate {return false}
        if _storage._setPageSwitch != rhs_storage._setPageSwitch {return false}
        if _storage._setCheckGpsInfo != rhs_storage._setCheckGpsInfo {return false}
        if _storage._setUpdateGpsData != rhs_storage._setUpdateGpsData {return false}
        if _storage._setUpdateSpo2Data != rhs_storage._setUpdateSpo2Data {return false}
        if _storage._getDialConfigData != rhs_storage._getDialConfigData {return false}
        if _storage._setWarmingData != rhs_storage._setWarmingData {return false}
        if _storage._setMenuSeqData != rhs_storage._setMenuSeqData {return false}
        if _storage._getMenuSeqData != rhs_storage._getMenuSeqData {return false}
        if _storage._rGetMenuSeqData != rhs_storage._rGetMenuSeqData {return false}
        if _storage._getNfcCardData != rhs_storage._getNfcCardData {return false}
        if _storage._setSpo2Detect != rhs_storage._setSpo2Detect {return false}
        if _storage._rGetSpo2Detect != rhs_storage._rGetSpo2Detect {return false}
        if _storage._swsnInfo != rhs_storage._swsnInfo {return false}
        if _storage._setPhoneAppStatus != rhs_storage._setPhoneAppStatus {return false}
        if _storage._setFemaleHealthInfo != rhs_storage._setFemaleHealthInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension hl_cmds.cmd_t: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CMD_BIND_DEVICE"),
    2: .same(proto: "CMD_GET_DEVICE_INFO"),
    3: .same(proto: "CMD_SYNC_PHONE_INFO"),
    4: .same(proto: "CMD_SYNC_USER_INFO"),
    5: .same(proto: "CMD_SYNC_SWITCH"),
    6: .same(proto: "CMD_SET_HR_SAMPLE_SLOT"),
    7: .same(proto: "CMD_SET_LONGSIT_DURATION"),
    8: .same(proto: "CMD_SET_DRINK_SLOT"),
    9: .same(proto: "CMD_SET_ALARMS"),
    10: .same(proto: "CMD_SET_NOTDISTURB"),
    11: .same(proto: "CMD_SET_COUNTRY_INFO"),
    12: .same(proto: "CMD_SET_UI_STYLE"),
    13: .same(proto: "CMD_SET_SPORT_TARGET"),
    14: .same(proto: "CMD_SET_TIME_FORMAT"),
    15: .same(proto: "CMD_SET_METRIC_INCH"),
    16: .same(proto: "CMD_SET_BRIGHT_TIMES"),
    17: .same(proto: "CMD_SET_HR_WARNING"),
    18: .same(proto: "CMD_GET_HR_VALUE"),
    19: .same(proto: "CMD_SET_NOTIFY_WARN"),
    20: .same(proto: "CMD_SET_SYNC_HEALTH_DATA"),
    21: .same(proto: "CMD_GET_POWER_VALUE"),
    22: .same(proto: "CMD_SET_UPDATA_FW"),
    23: .same(proto: "CMD_SET_TAKE_PIC"),
    24: .same(proto: "CMD_SET_FIND_PHONE"),
    25: .same(proto: "CMD_SET_FIND_DEV"),
    26: .same(proto: "CMD_SET_WEATHER_INFO"),
    27: .same(proto: "CMD_SET_RESET_MACHINE"),
    28: .same(proto: "CMD_SET_SPORT_STATUS"),
    29: .same(proto: "CMD_GET_HEALTH_DATA"),
    30: .same(proto: "CMD_SET_MUSIC_INFO"),
    31: .same(proto: "CMD_GET_SYNC_MTU"),
    32: .same(proto: "CMD_SET_BIN_DATA_UPDATE"),
    33: .same(proto: "CMD_FACTORY_TEST_MODE"),
    34: .same(proto: "CMD_SEND_BIG_DATA"),
    35: .same(proto: "CMD_GET_REALTIME_HR"),
    36: .same(proto: "CMD_SYNC_REALTIME_HR"),
    37: .same(proto: "CMD_HAND_UP_PHONE"),
    38: .same(proto: "CMD_DISTURB_SWITCH"),
    39: .same(proto: "CMD_CTR_APP_SPORTS"),
    40: .same(proto: "CMD_SYNC_STEP_COUNT"),
    41: .same(proto: "CMD_CHECK_SPORT_STATUS"),
    42: .same(proto: "CMD_GET_CURRENT_SPORT_HR"),
    43: .same(proto: "CMD_SET_MAKE_TEST_DATA"),
    44: .same(proto: "CMD_SET_LIGHT_LEAK_RESULT"),
    45: .same(proto: "CMD_GET_ACTIVE_RECORD_DATA"),
    46: .same(proto: "CMD_SET_ACTIVE_RECORD_DATA"),
    47: .same(proto: "CMD_SET_LOG_INFO_DATA"),
    48: .same(proto: "CMD_GET_LOG_INFO_DATA"),
    49: .same(proto: "CMD_GET_UI_HRS_VALUE"),
    50: .same(proto: "CMD_SET_ALL_CONFIG_PARAM"),
    51: .same(proto: "CMD_SET_NFC_OPERATE_CODE"),
    52: .same(proto: "CMD_SET_PAGE_SWITCH"),
    53: .same(proto: "CMD_SET_CHECK_GPS_INFO"),
    54: .same(proto: "CMD_SET_UPDATE_GPS_DATA"),
    55: .same(proto: "CMD_GET_UPDATE_SPO2_DATA"),
    56: .same(proto: "CMD_GET_DIAL_CONFIG_DATA"),
    57: .same(proto: "CMD_SET_WARMING_DATA"),
    58: .same(proto: "CMD_GET_MENU_SEQUENCE_DATA"),
    59: .same(proto: "CMD_SET_MENU_SEQUENCE_DATA"),
    60: .same(proto: "CMD_NFC_ACCESS_CARD_DATA"),
    61: .same(proto: "CMD_SET_SPO2_DETECT"),
    62: .same(proto: "CMD_GET_SPO2_DETECT"),
    63: .same(proto: "CMD_SWSN_GET_DATA_INFO"),
    64: .same(proto: "CMD_SWSN_SET_DATA_INFO"),
    65: .same(proto: "CMD_PHONE_APP_SET_STATUS"),
    66: .same(proto: "CMD_GET_ALARMS"),
    67: .same(proto: "CMD_SET_FEMALE_HEALTH_INFO"),
  ]
}
